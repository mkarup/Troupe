#+TITLE: Process supervision and monitoring in Troupe
#+STARTUP: fnadjust
#+OPTIONS: toc:2

This design document serves as an overview for integrating a security aware supervision mechanism
into the Troupe language. The intent is to identify requirements and challenges, including security
considerations, and design such a mechanism, with the goal of developing an MVP/prototype. The
supervision mechanism will enable processes to selectively monitor the lifecycle of other processes,
link the lifecycle of two processes, detect failures, and implement custom recovery logic, while
preserving Troupe's security guarantees.

*NOTE: The code snippets are meant to serve as illustrations/pseudo-code, and may not constitute complete programs, and syntax may not be correct.*

* Introduction

Troupe is a programming language for concurrent and distributed programming with dynamic information flow control.
As a research language, Troupe is focused on exploring new approaches to ensuring secure information flow in decentralized, multi-party systems.

One key limitation of the current Troupe design is the lack of a /supervision/ mechanism, the ability for processes to monitor and respond to the termination of other processes.
This limits the ability to handle and recover from unexpected failures, which is crucial for building reliable and fault-tolerant distributed applications.

** Motivation

- *Error handling and recovery*: Improve the reliability of Troupe programs by monitoring for and handling unexpected failure of processes.
- *Separation of concern*: Separate core application (business) logic from failure handling logic for more modular program design.
- *Fault tolerance*: Isolate the failure of system components by automatically restarting or replacing them, maintaining overall availability of the system.

** Requirements

An effective and reliable supervision monitoring mechanism must, at minimum, satisfy the following functional properties:
1. Ensure that it is possible to reliably detect process failure.
2. Ensure that processes that depend/rely on one another can be shut down in a coordinated fashion.
3. Ensure that it is possible to terminate processes that may be unresponsive or 'stuck' in a bad/corrupt state.
4. Ensure that the above works on both an intra- and inter-node level.
5. Ensure that the above does not leak information.

** Challenges

*** Security considerations.

1. *Information leakage*: The ability to detect termination events introduces new channels for information leakage. For example, if a lower-security process is able to detect the termination of a higher-security process, this could reveal information about the internal state or behavior of the higher-security process, compromising confidentiality.
2. *Covert channels*: A termination notification channel has the potential to act as a covert channel that allows bypassing the intended information flow control restrictions.
3. *Denial of service*: A supervision mechanism could be vulnerable to denial of service attacks, for example by repeatedly creating and terminating processes.

*** Practical considerations

(Of minor importance)

1. *Efficiency*: Minimize performance and networking overhead related to supervision.
2. *Portability*: Minimize reliance on system/networking specifics (implement as much of the functionality as possible in Troupe itself).
3. *Usability and ergonomics*: Reduce the cognitive overhead related to using the mechanisms.

* Approach

** Inspirations for supervision functionality

Inspiration drawn from popular systems for building robust and fault tolerant distributed systems:
- [[https://www.erlang.org/][Erlang]] relies heavily on /exit signals/ and the process linking/monitoring mechanisms for error handling, including the implementation of supervision (see sections on [[https://www.erlang.org/doc/system/robustness.html#error-handling][error handling]], [[https://www.erlang.org/doc/system/design_principles.html][the OTP design principles]] and [[https://www.erlang.org/doc/system/sup_princ.html][the supervision behavior]] in the Erlang system documentation)
- [[http://haskell-distributed.github.io/][Cloud Haskell]] has almost the same linking/monitoring mechanisms as Erlang, except that the semantics are slightly simpler, since process linking is unidirectional (see the sections on [[http://haskell-distributed.github.io/tutorials/3ch.html#monitoring-and-linking][monitoring and linking]] and [[http://haskell-distributed.github.io/tutorials/3ch.html#process-lifetime][process lifetime]] in the Cloud Haskell documentation)
- [[https://akka.io/][Akka]] also uses a flavor of the linking and monitoring approach (see the section on [[https://doc.akka.io/libraries/akka-core/current/general/supervision.html][supervision and monitoring]] in the Akka documentation)

** Can we re-use Troupe's message passing features to implement it?

Troupe's current message passing mechanism alone cannot be relied on:
- Processes may terminate unexpectedly due to e.g. run-time errors, meaning that they are not able
  to send a message to their supervisor before terminating, and processes must be aware that they
  are supervised to receive termination request from supervisors.
- There is no way to guarantee that a supervisee is terminated if the supervisor terminates
  unexpectedly, leading to orphaned processes.
- There is no way to force the termination of a process, e.g. if it is stuck in bad/corrupted state
  that is blocking other processes or tying up system resources.

** Designing a security aware supervision API

1. Start by establishing the basic functionality (at first without considering security/IFC)
2. Refine the design to be secure by identifying potential issues
3. Implement MVP

*** Basic supervision API, v1

To start off, a base API consisting of 3 primitives based on Erlang/Cloud Haskell/Akka could be as follows:
- ~link : pid -> ()~: /Link/ the calling process (the "linker") to process ~pid~ (the "linkee"). If the linkee
  terminates, for any reason, so does the linker (but not the other way around!)[fn:1].
  - Contrary to Erlang, links are defined to be unidirectional, as this simplifies the semantics.
    The linking mechanism in both Cloud Haskell and Akka is also unidirectional.
    Additionally, unidirectional linking was also proposed as part of
    [[https://dl.acm.org/doi/10.1145/1863509.1863514][an effort to provide a simpler formalization of Erlang's
    semantics]].
    
- ~monitor : pid -> monRef~: /Monitor/ process ~pid~. If ~pid~ terminates, the calling process will receive a /termination message/ in the mailbox.
  The call returns a /monitor references/, which uniquely identifies the monitoring relationship.
  The termination message will include the monitor reference, ID of the terminated process and the termination /reason/.
  Termination may be normal or abnormal, e.g. due to a failure such as a run-time error.
  If the termination reason is abnormal, the error (message) will also be included.
  
- ~terminate : pid -> ()~: /Terminate/ process ~pid~, which will force the termination of ~pid~ (similar to Erlang's ~exit/2~, Cloud Haskell's ~kill~ and Akka's ~stop~).

With these primitives in hand, a very simple generic 1-child supervisor could look something like the following:
#+BEGIN_SRC sml
let fun supervise child_fun =
        let val sup_pid = self()
            val child_pid =
                spawn (fn () =>
                          (* Link to the supervisor first
                             to ensure that the child process
                             is terminated if the supervisor
                             dies *)
                          let val _ = link sup_pid
                          in child_fun ()
                          end)
            (* Monitor for the termination of the child *)
            val mon_ref = monitor child_pid
        in
          receive [
            hn ("DOWN", mon_ref', pid, reason) when mon_ref' = mon_ref =>
            (* Handle the termination appropriately,
               e.g. by restarting/respawning the child *)
            ...

            hn "SHUTDOWN" =>
            (* Shut down the supervisor and child process,
             e.g. if requested from a supervisor higher in the
             supervision hierarchy
             (in practice, a 'graceful' shutdown protocol
             may be implemented by sending a shutdown request
             with a timeout to the child first *)
            terminate child_pid
          ]
        end
in
  ...
end
#+END_SRC

[fn:1] Contrary to Erlang, the links are defined to be *unidirectional*, as this (arguably) simplifies the semantics/reasoning about linking behavior. The linking mechanism in both Cloud Haskell and Akka is also unidirectional. Additionally, unidirectional linking was also proposed as part of [[https://dl.acm.org/doi/10.1145/1863509.1863514][an effort to provide a simpler formalization of Erlang's semantics]].

**** Remote linking and monitoring functionality

To be useful for supervision, the API should work both on a local and cross-node level.

To facilitate this, there needs to be a notion of two nodes being "connected", in terms of linking/monitoring.
Initiating a monitoring/linking relationship between processes on two nodes establishes the connection, if they were not already connected, and the connection is maintained as long as there is at least one active monitor/link[fn:2].

In case of a disconnect, which may be due to the failure of a node or a network partition, monitoring/linking relationships between processes on the now disconnected nodes must be broken:
- Processes that have linked themselves to a process on the disconnected node must be terminated.
- Processes that are monitoring a process on the disconnected node must be notified (with failure reason being a disconnect).
  
It may be the case, e.g. due to network instability, that a disconnected node later rejoins the network, *without realizing that it was disconnected*, and it may still assume that links/monitors established in the previous connection are active.
When this happens, disconnected node must be informed of the disconnect, such that the nodes agree on which monitoring/linking relationships (which may mean retroactively terminating links or informing monitors).

[fn:2] In practice, connections between nodes can be maintained through the use of periodic "heartbeats", which can be implemented (mostly) in the Troupe language itself.

**** Issues with v1

1. Linking and monitoring opens a new covert channel through process termination
   - Monitoring a process can leak information about the context in
     which it terminates, e.g. when branching on a secret conditional.
     Consider a process p running code that contains the following snippet:
     #+begin_src sml :eval no
     (* ... *)
     if secret then
       1 / 0
     else
       ()
     #+end_src
     Now consider another process Q, running the following code:
     #+begin_src sml :eval no
     let
       (* obtain pid ... *)
       val ref = monitor P
     in
       receive [
         hn ("DOWN", ref', pid, "NORMAL") => print "So it was false, huh",
         hn ("DOWN", ref', pid, err)      => print "So it was true, huh"
       ]
     end
     #+end_src
     Since the reason for termination depends on the value of ~secret~, Q can learn it through the shape of the termination message received through monitoring.
     If Q is local, this can be relayed to an untrusted remote receiver.

   - Similarly, linking or monitoring a process can also leak information about the context of the process, but in a more subtle way.
     Consider a process P running code that contains the following snippet:
     #+begin_src sml :eval no
     (* ... *)
     if secret then
       1 / 0
     else
       (* ... *)
     #+end_src
     Now consider another process Q_{1}, which may be local, running the following code:
     #+begin_src sml :eval no
     let val _ = link P
         fun loop i =
             let val _ = send (Q2, i)
             in loop (i + 1)
             end
     in
       loop 0
     end
     #+end_src
     Assuming that the network is reasonably reliable, the value of ~secret~ can be learned by Q_{2}, which may be an untrusted remote receiver:
     Since P_{1} is executing in a public context, there is nothing stopping it from continuously sending "heartbeats" to Q_{2} - it is in a
     public context - thereby leaking information through the lack of output.
     This type of leak can also be achieved using a monitor instead of a link.

2. Terminating a process using the ~terminate~ function can also be used to leak information.
   Consider a process P, running the code:
   #+begin_src sml :eval no
   (* ... *)
   if secret then
     terminate Q1
   else
     terminate Q2
   #+end_src
   and processes Q_{i}, running the code
   #+begin_src sml :eval no
   let fun loop n =
           let val _ = send (Q, (i, n))
           in loop (n + 1)
           end
   in
     loop 0
   end
   #+end_src
   Like with linking and monitoring, Q can learn the value of ~secret~ through the absence of output from either Q_{1} or Q_{2}.

3. Linking poses a potential availability concern, as an adversary can
   cause a (long running) process to link to another process under the adversary's
   control, e.g. when evaluating untrusted code, and thereby
   indirectly kill the linked process:
   #+begin_src sml :eval no
   let val kill_pid = spawn(fn () => receive [ hn "die" => 1 / 0 ])
       fun kill_fun () = link kill_pid
       val _ = send (P, kill_fun)
   in
     (* ... *)
     send (kill_pid, "die")
   end
   #+end_src

4. The ability to terminate arbitrary processes also directly enables a denial-of-service attack by
   killing off processes.

*** Securing links, monitors and process termination (API, v2)

An attempt at refining the v1 API to address/mitigate the security related issues.

Both monitoring and linking can be seen as a "delayed" form of (indirect) message passing:
- Monitoring/ linking to a process conceptually results in that process sending a termination signal/message to the monitor/linker, "just before it terminates"
- Monitors must /explicitly/ receive it by inspecting the mailbox (calling ~receive~ with an appropriate handler)
- Links /implicitly/ receive it, at any point in the program, circumventing the mailbox
- If the terminating process is in secret context (PC/blocking level), e.g. by branching on a secret value, it must be prevented from sending termination signals/messages to public processes, i.e. 'no write down'

Additionally, linking and forcefully terminating a process (i.e. calling ~terminate~ it) can (unexpectedly) interrupt the control flow at any point in a program, which is potentially publicly observable.

**** Linking

A challenge in dealing with the leak in the linking example of the previous section is that by the time the violation is identified, it's already "too late" - we do not know ahead of time the context in which a process will terminate, and by the time the runtime kills the linker, information may have already leaked through the progress channel.

One way to address this is to modify the ~link~ function to also take a security label, say l_{1}, in addition to the ID of the process to link with, and calling the function raises the blocking label of the caller to l_{1}. When the process being linked to terminates with blocking level l_{2}, the termination signal/message will only be "received", something that happens implicitly, if l_{2} ⊑ l_{1}, i.e. /a public process is allowed to send information to a secret process, and the secret process is allowed to read it./

In the example from ..., if the label supplied to the ~link~ function is higher than that of P_{3}, the first call to ~send~ will cause the runtime security monitor to terminate P_{2} due to an IFC violation, and P_{3} will never receive /any/ heartbeats, preventing a leak through the divergence of P_{2}.

An unfortunate side effect of this is that the guarantees that programmers get on linking are "weakened" (relative to e.g. Erlang):
Whether the linker (the caller of ~link~) will be terminated when the linkee (the argument supplied to the ~link~ call) terminates, depends on the PC/blocking level of the linkee, and this might evolve unexpectedly and thus make it less reliable.

**** Monitoring

One way to ensure that information about the execution context (e.g. which branches have been taken)
is not leaked /directly/ via monitoring, is to taint the termination message/signal with the blocking
level of the process at the point of termination.

Assuming that the normal message passing mechanism is used for sending/delivery, the run-time
monitor can enforce a secure information flow:
- Termination messages bound for external monitors at untrusted nodes will be blocked
- Local monitors must either be operating in a security context that is at least as confidential as
  the terminated process, or explicitly raise the blocking level (temporarily), in order to receive
  the termination message.
- This in turn means that they cannot perform any publicly observable actions without the authority
  to lower the blocking level, and they cannot relay the termination message without declassifying
  it.

This will ensure that an external monitor on an untrusted node cannot learn about termination that
was influenced by confidential information. A local monitor will not be able to receive messages
without operating in a secret context, and thus cannot leak information through heartbeats.
Similar to linking, this slightly "weakens" the guarantees on the monitoring relationship, in the sense that
whether a termination message is delivered depends on the PC/blocking level of a process,
which might evolve unexpectedly.

**** TODO Monitoring or linking to an "already dead" process

**** Termination

- Termination poses both a confidentiality and availability issue, if any process is allowed to terminate any other process
- To simplify both the low level API and the security analysis of it, process termination can be provided in a restricted form.
- The main use case is supervision, in which a supervisor will have responsibility over a number of child processes, e.g. spawning and re-spawning them.
- In such a scenario, it makes sense to allow the parent of a process to terminate a child.
- This can be done programmatically, using the link primitive.

**** Cross-node monitoring/linking requests

- /Outgoing/ monitor/link request: If ~p~ in context l_{p}, wants to monitor/link to ~q~ on node ~n~, and node ~n~ is trusted to lvl l_{n}, only allow the /outbound/ request if l_{p} ⊑ l_{n} (additionally also take the level of the link into account), otherwise terminate with IFC violation (since it's equivalent of sending a message)

- /Incoming/ monitor/link request: If node n with trust level l_{n}, wants to monitor/link to local process p, only honor the request (i.e. send the termination signal/message back) if p terminates in context l_{p} such that l_{p} ⊑ l_{n} (additionally also take the level of the link into account)

* Resources

- "Programming Erlang" (2nd Edition), Armstrong, 2013
- [[https://dl.acm.org/doi/10.1145/1863509.1863514][A unified semantics for future Erlang]], Svensson, Fredlun & Benac-Earle, 2010
- [[https://haskell-distributed.github.io/static/semantics.pdf][Cloud Haskell Semantics (draft pdf)]]
- [[https://ieeexplore.ieee.org/abstract/document/1212703][Observational determinism for concurrent program security]], Zdancewic & Myers, 2003
- [[https://ieeexplore.ieee.org/abstract/document/5207637][Noninterference for a practical DIFC-based operating system]], Krohn & Tromer, 2009
