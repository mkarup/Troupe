#+TITLE: Process supervision and monitoring in Troupe
#+STARTUP: fnadjust
#+OPTIONS: toc:2

This design document serves as an overview for integrating a security aware supervision mechanism
into the Troupe language. The intent is to identify requirements and challenges, including security
considerations, and design such a mechanism, with the goal of developing an MVP/prototype. The
supervision mechanism will enable processes to selectively monitor the lifecycle of other processes,
link the lifecycle of two processes, detect failures, and implement custom recovery logic, while
preserving Troupe's security guarantees.

*NOTE: The code snippets are meant to serve as illustrations/pseudo-code, syntax may not be correct.*

* Introduction

Troupe is a programming language for concurrent and distributed programming with dynamic information flow control.
As a research language, Troupe is focused on exploring new approaches to ensuring secure information flow in decentralized, multi-party systems.

One key limitation of the current Troupe design is the lack of a /supervision/ mechanism, the ability for processes to monitor and respond to the termination of other processes.
This limits the ability to handle and recover from unexpected failures, which is crucial for building reliable and fault-tolerant distributed applications.

** Motivation

- *Error handling and recovery*: Improve the reliability of Troupe programs by monitoring for and handling unexpected failure of processes.
- *Separation of concern*: Separate core application (business) logic from failure handling logic for more modular program design.
- *Fault tolerance*: Isolate the failure of system components by automatically restarting or replacing them, maintaining overall availability of the system.

** Requirements

An effective and reliable supervision monitoring mechanism must, at minimum, satisfy the following functional properties:
1. Ensure that it is possible to reliably detect process failure.
2. Ensure that processes that depend/rely on one another can be shut down in a coordinated fashion.
3. Ensure that it is possible to terminate processes that may be unresponsive or 'stuck' in a bad/corrupt state.
4. Ensure that the above works on both an intra- and inter-node level.
5. Ensure that the above does not leak information.

** Challenges

*** Security considerations.

1. *Information leakage*: The ability to detect termination events introduces new channels for information leakage. For example, if a lower-security process is able to detect the termination of a higher-security process, this could reveal information about the internal state or behavior of the higher-security process, compromising confidentiality.
2. *Covert channels*: A termination notification channel has the potential to act as a covert channel that allows bypassing the intended information flow control restrictions.
3. *Denial of service*: A supervision mechanism could be vulnerable to denial of service attacks, for example by repeatedly creating and terminating processes.

*** Practical considerations

(Of minor importance)

1. *Efficiency*: Minimize performance and networking overhead related to supervision.
2. *Portability*: Minimize reliance on system/networking specifics (implement as much of the functionality as possible in Troupe itself).
3. *Usability and ergonomics*: Reduce the cognitive overhead related to using the mechanisms.

* Approach

Troupe's current message passing mechanism alone cannot be relied on:
- Processes may terminate unexpectedly due to e.g. run-time errors,
  meaning that they are not able to send a message to their supervisor
  before terminating, and processes must be aware that they are
  supervised to receive termination request from supervisors.
- There is no way to guarantee that a supervisee is terminated if the
  supervisor terminates unexpectedly, leading to orphaned processes.
- There is no way to force the termination of a process, e.g. if it is
  stuck in bad/corrupted state that is blocking other processes or
  tying up system resources.

** Inspirations for supervision functionality

Inspiration drawn from popular systems for building robust and fault tolerant distributed systems: 
- [[https://www.erlang.org/][Erlang]] relies heavily on /exit signals/ and the process linking/monitoring mechanisms for error handling, including the implementation of supervision (see sections on [[https://www.erlang.org/doc/system/robustness.html#error-handling][error handling]], [[https://www.erlang.org/doc/system/design_principles.html][the OTP design principles]] and [[https://www.erlang.org/doc/system/sup_princ.html][the supervision behavior]] in the Erlang system documentation)
- [[http://haskell-distributed.github.io/][Cloud Haskell]] has almost the same linking/monitoring mechanisms as Erlang, except that the semantics are slightly simpler, since process linking is unidirectional (see the sections on [[http://haskell-distributed.github.io/tutorials/3ch.html#monitoring-and-linking][monitoring and linking]] and [[http://haskell-distributed.github.io/tutorials/3ch.html#process-lifetime][process lifetime]] in the Cloud Haskell documentation)
- [[https://akka.io/][Akka]] also uses a flavor of the linking and monitoring approach (see the section on [[https://doc.akka.io/libraries/akka-core/current/general/supervision.html][supervision and monitoring]] in the Akka documentation)

** Designing a supervision API

1. Start by establishing the basic functionality, at first without considering security/IFC
2. Refine the design to be secure by identifying potential issues
3. Repeat step 2
4. ???
5. Profit

*** Basic supervision API, v1

To start off, a base API consisting of 3 primitives based on Erlang/Cloud Haskell/Akka could be as follows:
- ~link : pid -> ()~: /Link/ the calling process (the "linker") to process ~pid~ (the "linkee"). If the linkee
  terminates, for any reason, so does the linker (but not the other way around!)
  - Contrary to Erlang, links are defined to be unidirectional, as
    this simplifies the semantics. The linking mechanism in both Cloud Haskell and Akka is also unidirectional.
    Additionally, unidirectional linking was also proposed as part of
    [[https://dl.acm.org/doi/10.1145/1863509.1863514][an effort to provide a simpler formalization of Erlang's
    semantics]].
- ~monitor : pid -> monRef~: /Monitor/ process ~pid~. If ~pid~ terminates, the
  calling process will receive a /termination message/ in the mailbox.
  The message will contain a /reason/, which describes how ~pid~
  terminated, e.g. normally or due to a run-time error.   
- ~terminate : pid -> ()~: Send a /termination signal/ to process ~pid~,
  which will force the termination of ~pid~ (similar to Erlang's ~exit/2~,
  Cloud Haskell's ~kill~ and Akka's ~stop~).


With these primitives in hand, a very simple generic supervisor could look something like the following:
#+BEGIN_SRC sml
let fun supervise child_fun =
        let val sup_pid = self()
            val child_pid =
                spawn (fn () =>
                          (* Link to the supervisor first
                             to ensure that the child process
                             is terminated if the supervisor
                             dies *)
                          let val _ = link sup_pid
                          in child_fun ()
                          end)
            (* Monitor for the termination of the child *)
            val mon_ref = monitor child_pid
        in
          receive [
            hn ("DOWN", mon_ref', pid, reason) when mon_ref' = mon_ref =>                        
            (* Handle the termination appropriately,
               e.g. by restarting/respawning the child *)
            ...

            hn "SHUTDOWN" =>
            (* Shut down the supervisor and child process,
             e.g. if requested from a supervisor higher in the
             supervision hierarchy
             (in practice, a 'graceful' shutdown protocol
             may be implemented by sending a shutdown request
             with a timeout to the child first *)
            terminate child_pid
          ]
        end
in
  ...
end
#+END_SRC

**** Remote linking and monitoring

To be useful for supervision, the API should work both on a local and
cross-node level (it may be useful to provide variants of the above
that also take a node id, similar to the spawn function).

To facilitate this, there needs to be a notion of two nodes being
"connected". In case of a disconnect, which may be due to the failure
of a node or a network partition, local processes that are either
linking to or monitoring processes on the disconnected node must be
notified: The linked processes must be terminated, and the monitoring
processes must receive a termination message.

In practice, connections between nodes can be maintained through the
use of periodic "heartbeats", which can be implemented (mostly) in the
Troupe language itself.

**** Issues with v1

1. Linking and monitoring opens a new covert channel through process termination
   - Monitoring a process can leak information about the context in
     which it terminates, e.g. when branching on a high conditional,
     if this is not taken into account when relaying the termination
     message.
     Consider a process P_{1} running code that contains the
     following snippet:
     #+begin_src sml :eval no
     (* ... *)
     if secret then
       1 / 0
     else
       ()
     #+end_src
     Now consider another process P_{2}, running the following code:
     #+begin_src sml :eval no
     let
       (* obtain pid ... *)
       val ref = monitor P1
     in
       receive [
         hn ("DOWN", ref', pid, "NORMAL") => print "So it was false, huh",
         hn ("DOWN", ref', pid, err)      => print "So it was true, huh"
       ]
     end
     #+end_src
     
   - Similarly, linking or monitoring a process can also leak information about the context of the process, but in a more subtle way.
     Consider a process P_{1} running code that contains the following snippet:
     #+begin_src sml :eval no
     (* ... *)
     if secret then
       1 / 0
     else
       (* ... *)
     #+end_src
     Now consider another process P_{2}, which may be local, running the following code:
     #+begin_src sml :eval no
     let val _ = link pid
         fun loop i =
             let val _ = send (P3, i)
                 val _ = sleep 250
             in loop (i + 1)
     in
       loop 0
     end
     #+end_src
     Assuming that the network is reasonably reliable, the value of ~secret~
     can be exfiltrated to P_{3}, which may be residing on a remote, untrusted
     node. Since P_{2} is executing in a public context, there is nothing
     stopping it from continuously sending "heartbeats" to P_{3} - it is in a public context - thereby
     leaking information through the lack of output: If P_{1} dies, so does P_{2}.
     This can also be achieved using a monitor instead of link.     
     
2. Linking poses a potential availability concern, as an adversary can
   cause a (long running) process to link to another process under the adversary's
   control, e.g. when evaluating untrusted code, and thereby
   indirectly kill the linked process:   
     #+begin_src sml :eval no
     let val kill_pid = spawn(fn () => receive [ hn "die" => 1 / 0 ])
         fun kill_fun () = link kill_pid
         val _ = send (P, kill_fun)
     in
       (* ... *)
       send (kill_pid, "die")
     end
     #+end_src

3. The ability to terminate arbitrary processes also directly enables
   a denial-of-service attack by killing off processes.

*** Supervision API, v2

First, an attempt to modify the semantics to address/mitigate the confidentiality related issues identified with the basic API, postponing the availability concerns.

Both monitoring and linking can be seen as a "delayed" form of (indirect) message passing: The terminating process sends a "signal" (a generalized sort of message) to the monitor/linker.

**** Linking

One challenge in dealing with the leak in the linking example of the previous section is that by the time the violation is identified, it's already "too late" - we do not know ahead of time the context in which a process will terminate, and by the time the runtime kills the linker, information may have already leaked through the progress channel.

One way to address this is to modify the ~link~ function to also take a security label, say l_{1}, in addition to the ID of the process to link with, and calling the function raises the blocking label of the caller to l_{1}.
Additionally, the guarantees on linking must be "weakened" (relative to how it works in Erlang & friends) by only enforcing that the linker (caller) will be terminated, if the linkee terminated with a blocking label l_{2} equal to or lower than l_{1}, i.e. l_{2} ⊑ l_{1}. 

In the example from the previous section, if the label supplied to the ~link~ function is higher than that of P_{3}, the first call to ~send~ will cause the runtime security monitor to terminate P_{2} due to an IFC violation, and P_{3} will never receive /any/ heartbeats, preventing a leak through the divergence of P_{2}.

**** Monitoring

One obvious way to ensure that information about the execution context (e.g. which branches have been taken)
is not leaked /directly/ via monitoring, as illustrated in the previous section, is
to taint the termination message/signal with the blocking level of the process at the point of
termination.

Assuming that the normal message passing mechanism is used for
sending/delivery, the run-time monitor can enforce a secure information flow:
- Termination messages bound for external monitors at untrusted nodes will be blocked
- Local monitors must either be operating in a security
  context that is at least as confidential as the terminated process, or
  explicitly raise the blocking level temporarily, in order to receive
  the termination message. This in turn means that they cannot relay
  the information to others without the authority to declassify it and
  lower the blocking level.


For the example in the previous section, this will ensure that an external monitor on an untrusted
node cannot learn about termination that was influenced by confidential information. A local
monitor will not be able to receive messages without operating in a secret context, and thus cannot leak information through heartbeats.
Similar to linking, this slightly "weakens" the guarantees on the monitoring relationship,
in the sense that whether a termination message is delivered depends on the trust relationship
between nodes (in addition to network stability).

**** Issues with v2

Terminating a process using the ~terminate~ function can also be used to leak information, by combining it with links and monitors.
Consider a process P_{1} running code that contains the following snippet:
#+begin_src sml :eval no
(* ... *)
if secret then
  terminate P2
else
  (* ... *)
#+end_src
where P_{2} is some local process.
A third local process P_{3} can link itself to P_{2} and use the same heartbeat trick as earlier to exfiltrate the value of ~secret~.
If P_{2} is just some process that is operating in a public context and waiting indefinitely, the link can be public, and the heartbeats will go through.
Similarly, swapping the link for a monitor means that P_{3} can leak the information directly.

*** Supervision API, v3

One possible solution to deal with such a leak through the ~terminate~ function, is to also taint the termination signal that is sent when calling ~terminate~ with the context of the sender, and then /propagate/ that taint to the termination signal that is sent when the receiver terminates.
Essentially, the context of the receiving process is raised to the least upper bound of its current context and the senders context before it is terminated.

This means that the restrictions added on links and monitors in added v2 kicks in and prevents a leak like in the previous section:
P_{3} needs to be in a secret context in order to be linked to P_{2}, which means that it is not able to send heartbeats to untrusted nodes.
Similar, if P_{3} is monitoring P_{2}, it won't be able to receive any termination messages unless it is in a secret context. 

If the termination signal is sent to an untrusted node in a secret context, it also needs to be blocked.

* TODO Resources

/list of resources go here.../
