#+TITLE: Process supervision and monitoring in Troupe
#+STARTUP: fnadjust
#+OPTIONS: toc:2

This design document serves as an overview for integrating a security aware supervision mechanism into the Troupe language.
The intent is to identify requirements and challenges, including security considerations, and design such a mechanism, with the goal of developing an MVP/prototype.
The supervision mechanism will enable processes to selectively monitor the lifecycle of other processes, detect failures, and implement custom recovery logic,
while preserving Troupe's security guarantees.

* Introduction
:properties:
:custom_id: sec-introduction
:end:

Troupe is a programming language for concurrent and distributed programming with dynamic information flow control.
As a research language, Troupe is focused on exploring new approaches to ensuring secure information flow in decentralized, multi-party systems.

One key limitation of the current Troupe design is the lack of a /supervision/ mechanism, the ability for processes to monitor and respond to the termination of other processes.
This limits the ability to handle and recover from unexpected failures, which is crucial for building reliable and fault-tolerant distributed applications.

** Motivation
:properties:
:custom_id: sec-motivation
:end:

- *Error handling and recovery*: Improve the reliability of Troupe programs by monitoring for and handling unexpected failure of processes.
- *Separation of concern*: Separate core application (business) logic from failure handling logic for more modular program design.
- *Fault tolerance*: Isolate the failure of system components by automatically restarting or replacing them, maintaining overall availability of the system.

** Requirements
:properties:
:custom_id: sec-requirements
:end:

An effective and reliable supervision monitoring mechanism must, at minimum, satisfy the following functional properties:
1. The mechanism must be able to accurately and promptly detect process failure to be able to respond appropriately to them as they occur.
2. The mechanism must be able to forcefully terminate supervised processes, e.g. in order to reset a system component to a stable state.
4. The mechanism must apply on both an intra- and inter-node level.
5. The mechanism must not compromise confidentiality or violate the progress-sensitive noninterference security policy.

** Challenges
:properties:
:custom_id: sec-challenges
:end:

*** Security considerations.

1. *Information leakage*: The ability to detect termination events introduces new channels for information leakage. For example, if a lower-security process is able to detect the termination of a higher-security process, this could reveal information about the internal state or behavior of the higher-security process, compromising confidentiality.
2. *Covert channels*: A termination notification channel has the potential to act as a covert channel that allows bypassing the intended information flow control restrictions.
3. *Denial of service*: A supervision mechanism could be vulnerable to denial of service attacks, for example by repeatedly creating and terminating processes.

*** Practical considerations

1. *Efficiency*: Minimize performance and networking overhead related to supervision.
2. *Portability*: Minimize reliance on system/networking specifics (implement as much of the functionality as possible in Troupe itself).
3. *Usability and ergonomics*: Reduce the cognitive overhead related to using the mechanisms.

** Evaluation criteria
:properties:
:custom_id: sec-evaluation-criteria
:end:

1. Security assurance
   1. Does not introduce new ways to leak information or covert channels; does not violate progress-sensitive noninterference
   2. Robust against denial of service attacks/ availability vulnerabilities
2. Expressiveness and flexibility
   1. Handles different failure scenarios and recovery strategies
   2. Supports supervision at different levels of granularity
3. Usability and ergonomics
   1. Ease of use of supervision-related APIs/constructs
   2. Integrates with the rest of Troupe's programming model
4. Performance and scalability
   1. Minimizes performance overhead on supervised processes
   2. Handles a large number of concurrent supervision relationships without impacting the rest of the system

Consider trade-offs, e.g. a design that maximizes security assurance may come at the cost of reduced expressiveness or usability.

* Approach
:properties:
:custom_id: sec-approach
:end:

Troupe's current message passing mechanism alone cannot be relied on:
- Processes may terminate unexpectedly due to e.g. run-time errors,
  meaning that they are not able to send a message to their supervisor
  before terminating, and processes must be aware that they are
  supervised to receive termination request from supervisors.
- There is no way to guarantee that a supervisee is terminated if the
  supervisor terminates unexpectedly, leading to orphaned processes.
- There is no way to force the termination of a process, e.g. if it is
  stuck in bad/corrupted state that is blocking other processes or
  tying up system resources.

** Inspirations for supervision functionality

Inspiration drawn from popular systems for building robust and fault tolerant distributed systems: 
- [[https://www.erlang.org/][Erlang]] relies heavily on /exit signals/ and the process linking/monitoring mechanisms for error handling, including the implementation of supervision (see sections on [[https://www.erlang.org/doc/system/robustness.html#error-handling][error handling]], [[https://www.erlang.org/doc/system/design_principles.html][the OTP design principles]] and [[https://www.erlang.org/doc/system/sup_princ.html][the supervision behavior]] in the Erlang system documentation)
- [[http://haskell-distributed.github.io/][Cloud Haskell]] has almost the same linking/monitoring mechanisms as Erlang, except that the semantics are slightly simpler, since process linking is unidirectional (see the sections on [[http://haskell-distributed.github.io/tutorials/3ch.html#monitoring-and-linking][monitoring and linking]] and [[http://haskell-distributed.github.io/tutorials/3ch.html#process-lifetime][process lifetime]] in the Cloud Haskell documentation)
- [[https://akka.io/][Akka]] also uses a flavor of the linking and monitoring approach (see the section on [[https://doc.akka.io/libraries/akka-core/current/general/supervision.html][supervision and monitoring]] in the Akka documentation)

** Designing a supervision API

*** Basic supervision API, v1

A base API consisting of 3 primitives based on Erlang/Cloud Haskell/Akka could be as follows:
- ~link : pid -> ()~: /Link/ the calling process (the "linker") to process ~pid~ (the "linkee"). If the linkee
  terminates, for any reason, so does the linker (but not the other way around!)
  - Contrary to Erlang, links are defined to be unidirectional, as
    this simplifies the semantics. The linking mechanism in both Cloud Haskell and Akka is also unidirectional.
    Additionally, unidirectional linking was also proposed as part of
    [[https://dl.acm.org/doi/10.1145/1863509.1863514][an effort to provide a simpler formalization of Erlang's
    semantics]].
- ~monitor : pid -> monRef~: /Monitor/ process ~pid~. If ~pid~ terminates, the
  calling process will receive a /termination message/ in the mailbox.
  The message will contain a /reason/, which describes how ~pid~
  terminated, e.g. normally or due to a run-time error.   
- ~terminate : pid -> ()~: Send a /termination signal/ to process ~pid~,
  which will force the termination of ~pid~ (similar to Erlang's ~exit/2~,
  Cloud Haskell's ~kill~ and Akka's ~stop~).



With these primitives in hand, a very simple generic supervisor could look something like the following:
#+BEGIN_SRC sml
let fun supervise child_fun =
        let val sup_pid = self()
            val child_pid =
                spawn (fn () =>
                          (* Link to the supervisor first
                             to ensure that the child process
                             is terminated if the supervisor
                             dies *)
                          let val _ = link sup_pid
                          in child_fun ()
                          end)
            (* Monitor for the termination of the child *)
            val mon_ref = monitor child_pid
        in
          receive [
            hn ("DOWN", mon_ref', pid, reason) when mon_ref' = mon_ref =>                        
            (* Handle the termination appropriately,
               e.g. by restarting/respawning the child *)
            ...

            hn "SHUTDOWN" =>
            (* Shut down the supervisor and child process,
             e.g. if requested from a supervisor higher in the
             supervision hierarchy
             (in practice, a 'graceful' shutdown protocol
             may be implemented by sending a shutdown request
             with a timeout to the child first *)
            terminate child_pid
          ]
        end
in
  ...
end
#+END_SRC

**** Remote linking and monitoring

To be useful for supervision, the API should work both on a local and
cross-node level (it may be useful to provide variants of the above
that also take a node id, similar to the spawn function).

To facilitate this, there needs to be a notion of two nodes being
"connected". In case of a disconnect, which may be due to the failure
of a node or a network partition, local processes that are either
linking to or monitoring processes on the disconnected node must be
notified: The linked processes must be terminated, and the monitoring
processes must receive a termination message.

In practice, connections between nodes can be maintained through the
use of periodic "heartbeats", which can be implemented (mostly) in the
Troupe language itself.

**** Issues with v1

1. Linking and monitoring opens a new covert channel through process termination
   - Monitoring a process can leak information about the context in
     which it terminates, e.g. when branching on a high conditional,
     if this is not taken into account when relaying the termination
     message.
     Consider a process P_{1} running code that contains the
     following snippet:
     #+begin_src sml :eval no
     (* ... *)
     if secret then
       1 / 0
     else
       ()
     #+end_src
     Now consider another process P_{2}, running the following code:
     #+begin_src sml :eval no
     let
       (* obtain pid ... *)
       val ref = monitor P1
     in
       receive [
         hn ("DOWN", ref', pid, "NORMAL") => print "So it was false, huh",
         hn ("DOWN", ref', pid, err)      => print "So it was true, huh"
       ]
     end
     #+end_src
     
   - Similarly, linking to a process can also leak information about the context of the process, but in a more subtle way.
     Consider a process P_{1} running code that contains the following snippet:
     #+begin_src sml :eval no
     (* ... *)
     if secret then
       1 / 0
     else
       (* ... *)
     #+end_src
     Now consider another process P_{2}, which may be local, running the following code:
     #+begin_src sml :eval no
     let val _ = link pid
         fun loop i =
             let val _ = send (P3, i)
                 val _ = sleep 250
             in loop (i + 1)
     in
       loop 0
     end
     #+end_src
     Assuming that the network is reasonably reliable, the value of ~secret~
     can be exfiltrated to P_{3}, which may residing on a remote, untrusted
     node. Since P_{2} is executing in a public context, there is nothing
     stopping it from continuously sending "heartbeats" to P_{3}, thereby
     leaking information through /progress/.   
     
2. Linking poses a potential availability concern, as an adversary can
   cause a (long running) process to link to another process under the adversary's
   control, e.g. when evaluating untrusted code, and thereby
   indirectly kill the linked process:   
     #+begin_src sml :eval no
     let val kill_pid = spawn(fn () => receive [ hn "die" => 1 / 0 ])
         fun kill_fun () = link kill_pid
         val _ = send (P, kill_fun)
     in
       (* ... *)
       send (kill_pid, "die")
     end
     #+end_src

3. The ability to terminate arbitrary processes also directly enables
   a denial-of-service attack by killing off processes.

*** Supervision API, v2

First, an attempt to modify the semantics to address/mitigate the confidentiality related issues identified with the basic API (postpone availability concerns).
Both monitoring and linking can be seen as a "delayed" form of (indirect) message passing: The terminating process sends a "signal" (a generalized sort of message) to the monitor/linker.
This communication must also be subject to the enforcement of noninterference.

**** Linking

One challenge in dealing with the leak in the linking example of the previous section is that by the time the violation is identified, it's already "too late" - we do not know ahead of time the context in which a process will terminate, and by the time the runtime kills the linker, information may have already leaked through the progress channel.

One way to address this is to modify the ~link~ function to also take a security label, say l_{1}, in addition to the ID of the process to link with, and calling the function raises the blocking label of the caller to l_{1}.
Additionally, the guarantees on linking must be "weakened" (relative to how it works in Erlang & friends) by only enforcing that the linker (caller) will be terminated, if the linkee terminated with a blocking label l_{2} equal to or lower than l_{1}, i.e. l_{2} ⊑ l_{1}. 

In the example from the previous section, if the label supplied to the ~link~ function is higher than that of P_{3}, the first call to ~send~ will cause the runtime security monitor to terminate P_{2} due to an IFC violation, and P_{3} will never receive /any/ heartbeats, preventing a leak through the divergence of P_{2}.

**** Monitoring

One way to ensure that information about the execution context (e.g.
which branches have been taken) is not leaked via monitoring is to
taint the termination message/signal with the blocking level of the
process at the point of termination.

Assuming that the normal message passing mechanism is used for
sending/delivery, the run-time monitor can enforce a secure information flow:
- Termination messages bound for external monitors at untrusted nodes will be blocked
- Local monitor processes must either be operating in a security
  context that is at least as confidential as the terminated node, or
  explicitly raise the blocking level temporarily, in order to receive
  the termination message. This in turn means that they cannot relay
  the information to others without the authority to declassify it and
  lower the blocking level.


For the monitoring example in the previous section, this will ensure
that a monitor on an untrusted node cannot learn about termination
that was influenced by confidential information. Similar to linking,
this slightly "weakens" the guarantees on the monitoring relationship,
in the sense that whether a termination message is delivered depends
on the trust relationship between nodes (in addition to network stability).


**** Issues with v2

Leaking through the ~terminate~ function and transitivity:
- Imagine 3 local nodes, P1, P2 and P3.
- P3 is some process that is handling some confidential data.
- An attack can be mounted as follows:
  1. P1 first links to P2
  2. P1 continuously sends heartbeats to a remote untrusted node
  3. P2 just loops/blocks/sleeps indefinitely
  4. P3 branches on a confidential value, and depending on the result, sends a termination signal to P2
  5. P2 terminates, which in turn breaks the link, terminating P1
  6. The heartbeats to the remote node stops, leaking information

     
The same can be done using monitoring, i.e. if P1 is monitoring P2 instead of linking.


* Resources

/resources go here.../
