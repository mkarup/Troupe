#+TITLE: Process supervision and monitoring in Troupe
#+STARTUP: fnadjust
#+OPTIONS: toc:2 f:t todo:t

This document is meant to serve as an overview for integrating a security aware supervision mechanism into the Troupe language.
The intent is to identify requirements and challenges, including security considerations, and design such a mechanism, with the goal of developing an MVP/prototype.
The supervision mechanism will enable processes to selectively monitor the lifecycle of other processes, link the lifecycle of two processes, detect failures, and implement custom recovery logic, while
preserving Troupe's security guarantees.

*NOTE: The code snippets used throughout the document are meant to serve as illustrations/pseudo-code, and may not constitute complete programs, and syntax may not be correct.*

* Table of contents

- [[#introduction][Introduction]]
  - [[#motivation][Motivation]]
  - [[#requirements][Requirements]]
  - [[#challenges][Challenges]]
- [[#approach][Approach]]
  - [[#inspirations-for-supervision-functionality][Inspirations for supervision functionality]]
  - [[#designing-a-security-aware-supervision-api][Designing a security aware supervision API]]
    - [[#can-we-re-use-troupes-message-passing-features-to-implement-it][Can we re-use Troupe's message passing features to implement it?]]
    - [[#basic-supervision-api-v1][Basic supervision API, v1]]
    - [[#securing-links-monitors-and-process-termination-api-v2][Securing links, monitors and process termination (API, v2)]]
- [[#resources][Resources]]

* Introduction

Troupe is a programming language for concurrent and distributed programming with dynamic information flow control.
As a research language, Troupe is focused on exploring new approaches to ensuring secure information flow in decentralized, multi-party systems.

One key limitation of the current Troupe design is the lack of a /supervision/ mechanism, the ability for processes to monitor and respond to the termination of other processes.
This limits the ability to handle and recover from unexpected failures, which is crucial for building reliable and fault-tolerant distributed applications.

** Motivation

- *Error handling and recovery*: Improve the reliability of Troupe programs by monitoring for and handling unexpected failure of processes.
- *Separation of concern*: Separate core application (business) logic from failure handling logic for more modular program design.
- *Fault tolerance*: Isolate the failure of system components by automatically restarting or replacing them, maintaining overall availability of the system.

** Requirements

An effective and reliable supervision monitoring mechanism must, at minimum, satisfy the following functional properties:
1. Ensure that it is possible to reliably detect process failure.
2. Ensure that processes that depend/rely on one another can be shut down in a coordinated fashion.
3. Ensure that it is possible to terminate processes that may be unresponsive or 'stuck' in a bad/corrupt state.
4. Ensure that the above works on both an intra- and inter-node level.
5. Ensure that the above does not leak information.

** Challenges

*** Security considerations.

1. *Information leakage*: The ability to detect termination events introduces new channels for information leakage. For example, if a lower-security process is able to detect the termination of a higher-security process, this could reveal information about the internal state or behavior of the higher-security process, compromising confidentiality.
2. *Covert channels*: A termination notification channel has the potential to act as a covert channel that allows bypassing the intended information flow control restrictions.
3. *Denial of service*: A supervision mechanism could be vulnerable to denial of service attacks, for example by repeatedly creating and terminating processes.

*** Practical considerations

(Of minor importance)

1. *Efficiency*: Minimize performance and networking overhead related to supervision.
2. *Portability*: Minimize reliance on system/networking specifics (implement as much of the functionality as possible in Troupe itself).
3. *Usability and ergonomics*: Reduce the cognitive overhead related to using the mechanisms.

* Approach

** Inspirations for supervision functionality

Inspiration drawn from popular systems for building robust and fault tolerant distributed systems:
- [[https://www.erlang.org/][Erlang]] relies on process linking/monitoring mechanisms, explained below, for error handling, including the implementation of supervision (see sections on [[https://www.erlang.org/doc/system/robustness.html#error-handling][error handling]], [[https://www.erlang.org/doc/system/design_principles.html][the OTP design principles]] and [[https://www.erlang.org/doc/system/sup_princ.html][the supervision behavior]] in the Erlang system documentation)
- [[http://haskell-distributed.github.io/][Cloud Haskell]] has almost the same linking/monitoring mechanisms as Erlang, except that the semantics are slightly simpler, since process linking is unidirectional (see the sections on [[http://haskell-distributed.github.io/tutorials/3ch.html#monitoring-and-linking][monitoring and linking]] and [[http://haskell-distributed.github.io/tutorials/3ch.html#process-lifetime][process lifetime]] in the Cloud Haskell documentation)
- [[https://akka.io/][Akka]] also uses a flavor of the linking and monitoring approach (see the section on [[https://doc.akka.io/libraries/akka-core/current/general/supervision.html][supervision and monitoring]] in the Akka documentation)

*** Linking and monitoring in Erlang

**** Links and exit signals

Erlang provides a mechanism for /linking/ two processes together (the primitive/built-in ~link~ function).
When two processes are linked and one of them terminates, the other will be sent an /exit signal/, which is essentially a special type of message, and when the signal arrives at the other process, it will also terminate. A process can be linked to multiple other processes, forming networks of linked processes: Once one of them dies, the exit signal propagates throughout the network, potentially terminating all the processes.

It's important to note that the handling of exit signals is done by the Erlang runtime, including the termination of linked processes. This means that a linked process may be killed by the runtime at any point in a program, if the other end of the link dies.

In addition to the default link behavior of "mutually assured destruction", Erlang also provides a mechanism that allows programmers to specify how a process should act on incoming exit signals, by allowing it to "trap exits"[fn:1].
Concretely, this is done by setting a special flag on the current process: ~process_flag(trap_exit, true)~.
If the ~trap_exit~ flag is set, incoming exit signals will be converted to regular Erlang messages of the form ~{'EXIT', from, reason}~ and placed in the mailbox, and they can be received like any other message. The ~reason~ value describes how the sender of the signal terminated, e.g. due to a run-time error.

The ability to link processes and handle exit signals from other processes is the main building block of Erlang’s supervisors.

A supervisor process manages a number of child processes by starting, re-starting and stopping them, according to some policy.
The supervisor process is configured to trap exit signals, and is able to act on the termination of a child process via links, e.g. by re-starting it.
Due to the link, if the supervisor somehow terminates, so do the children, which means that there is no risk of child processes being orphaned.

[fn:1] In Erlang terminology, a process that is trapping exits is also called a /system process/.

**** Monitors

In addition to links, Erlang also provides a mechanism that allows a process to "monitor" the lifetime of another, meaning that it will be notified (with a message) when the other process terminates.
Note that this is essentially the same as allowing the process to trap exit signals and then linking to the other process, except that monitoring is unidirectional and doesn't affect how incoming exit signals are treated. 

** Designing a security aware supervision API

1. Start by establishing the basic functionality (at first without considering security/IFC)
2. Refine the design to be secure by identifying potential issues
3. Implement MVP

*** Can we re-use Troupe's message passing features to implement it?

Troupe's current message passing mechanism alone cannot be relied on:
- Processes may terminate unexpectedly due to e.g. run-time errors, meaning that they are not able
  to send a message to their supervisor before terminating, and processes must be aware that they
  are supervised to receive termination request from supervisors.
- There is no way to guarantee that a supervisee is terminated if the supervisor terminates
  unexpectedly, leading to orphaned processes.
- There is no way to force the termination of a process, e.g. if it is stuck in bad/corrupted state
  that is blocking other processes or tying up system resources.

*** Basic supervision API, v1

To start off, a base API consisting of 3 primitives based on Erlang/Cloud Haskell/Akka could be as follows:
- ~link : pid -> ()~: /Link/ the calling process (the "linker") to process ~pid~ (the "linkee"). If the linkee
  terminates, for any reason, so does the linker (but not the other way around!)[fn:2].

- ~monitor : pid -> monRef~: /Monitor/ process ~pid~. If ~pid~ terminates, the calling process will receive a /termination message/ in the mailbox.
  The call returns a /monitor references/, which uniquely identifies the monitoring relationship.
  The termination message will include the monitor reference, ID of the terminated process and the termination /reason/.
  Termination may be normal or abnormal, e.g. due to a failure such as a run-time error.
  If the termination reason is abnormal, the error (message) will also be included.

- ~terminate : pid -> ()~: /Terminate/ process ~pid~, which will force the termination of ~pid~ (similar to Erlang's ~exit~, Cloud Haskell's ~kill~ and Akka's ~stop~).
  The rationale for providing a way to forcefully terminate another process is to enable a supervisor kill a child process that doesn't respond to requests to shut down gracefully.


With these primitives in hand, a very simple generic 1-child supervisor could look something like the following:
#+BEGIN_SRC sml
let fun supervise child_fun =
        let val sup_pid = self()
            val child_pid =
                spawn (fn () =>
                          (* Link to the supervisor first to ensure that the child process
                             is terminated if the supervisor dies *)
                          let val _ = link sup_pid
                          in child_fun ()
                          end)
            (* Monitor for the termination of the child *)
            val mon_ref = monitor child_pid
        in
          receive [
            hn ("DOWN", mon_ref', pid, reason) when mon_ref' = mon_ref =>
            (* Handle the termination appropriately, e.g. by restarting/respawning the child *)
            ...

            hn "SHUTDOWN" =>
            (* Shut down the supervisor and child process,
             e.g. if requested from a supervisor higher in the supervision hierarchy
             (in practice, a 'graceful' shutdown protocol may be implemented by
             sending a shutdown request with a timeout to the child first *)
            terminate child_pid
          ]
        end
in
  ...
end
#+END_SRC

[fn:2] Contrary to Erlang, the links are defined to be *unidirectional*, as this (arguably) simplifies the semantics/reasoning about linking behavior. The linking mechanism in both Cloud Haskell and Akka is also unidirectional. Additionally, unidirectional linking was also proposed as part of [[https://dl.acm.org/doi/10.1145/1863509.1863514][an effort to provide a simpler formalization of Erlang's semantics]].

**** Remote linking and monitoring functionality

To be useful for supervision, the API should work both on a local and cross-node level.

To facilitate this, there needs to be a notion of two nodes being /connected/, in relation to linking/monitoring.
- Initiating a monitoring/linking relationship between processes (calling ~monitor~ or ~link~) on two different nodes establishes the connection, if they were not already connected.
- The connection is maintained as long as there is at least one active monitor/link[fn:3].

In case of a disconnect, which may be due to the failure of a node or a network partition, monitoring/linking relationships between processes on the now disconnected nodes must be broken:
- Processes that have linked themselves to a process on the disconnected node must be terminated.
- Processes that are monitoring a process on the disconnected node must be notified (with failure reason being a disconnect).

It may be the case, e.g. due to network instability, that a disconnected node later rejoins the network, *without realizing that it was disconnected*, and it may still assume that links/monitors established in the previous connection are active.
When this happens, disconnected node must be informed of the disconnect, such that the nodes agree on which monitoring/linking relationships (which may mean retroactively terminating links or informing monitors).

A discussion of the practical implementation details is postponed for now.

[fn:3] In practice, connections between nodes can be maintained through the use of periodic "heartbeats", which can be implemented (mostly) in the Troupe language itself. The practical details.

**** Issues with v1

The ~link~, ~monitor~ and ~terminate~ primitives introduce a new way for processes to interact, and this exposes a number of security issues.

1. Monitoring a process can leak information about the context in which it terminates, e.g. when branching on a secret conditional.
   Consider a process p running code that contains the following snippet:
   #+begin_src sml :eval no
   (* ... *)
   if secret then
     1 / 0
   else
     ()
   #+end_src
   Now consider another process q, running the following code:
   #+begin_src sml :eval no
   let val monref = monitor p
   in
     receive [
       hn ("DOWN", monref', pid, "NORMAL") => print "So it was false, huh",
       hn ("DOWN", monref', pid, err)      => print "So it was true, huh"
     ]
   end
   #+end_src
   Since the reason for termination depends on the value of ~secret~, q can learn it through the shape of the termination message received through monitoring.
   If q is local, this can be relayed to an untrusted remote receiver.

2. Similarly, linking to, or monitoring, a process can also leak information about the context of the process (e.g. after/inside conditionals that may depend on secret values), but in a more subtle way.
   Consider a process p running code that contains the following snippet:
   #+begin_src sml :eval no
   (* ... *)
   if secret then
     1 / 0
   else
     (* code that doesn't cause p to terminate... *)
   #+end_src
   Now consider another process q_{1}, which may be local, running the following code:
   #+begin_src sml :eval no
   let val _ = link p
       fun loop i =
           let val _ = send (q2, i)
           in loop (i + 1)
           end
   in
     loop 0
   end
   #+end_src
   This can leak the value of ~secret~ to a public, possibly remote, process q_{2}:
   Since q_{1} is executing in a public context, there is nothing stopping it from continuously sending "heartbeats" to q_{2} - it is in a
   public context - thereby leaking information through the lack of output.
   This type of leak can also be achieved if q_{1} uses a monitor instead of a link (while waiting for the potential termination message from p it can periodically send messages to itself, and then send a heartbeat to q_{2}).

3. Terminating a process using the ~terminate~ function can also be used to leak information, in almost the same way as above.
   Consider a process p, running the code:
   #+begin_src sml :eval no
   (* ... *)
   if secret then
     terminate q1
   else
     (* code that doesn't terminate q1 *)
   #+end_src
   and processes q_{1}, running the same code as in the previous example:
   #+begin_src sml :eval no
   let fun loop n =
           let val _ = send (q, (i, n))
           in loop (n + 1)
           end
   in
     loop 0
   end
   #+end_src
   Like with linking and monitoring, q_{2} can learn the value of ~secret~ through the absence of output q_{1}.

4. Linking also poses a potential availability concern, as an adversary can cause a process to link to another process under the adversary's control, e.g. when evaluating untrusted code, and thereby indirectly kill the linked process.
   As a somewhat contrived example, consider a worker process p that receives a function, evaluates it and sends the result back:
   #+begin_src sml :eval no
   let fun loop () =
           let val (f, args, receiver) = receive [ hn (f, args, receiver) => (f, args, receiver) ]
               val result = f args
               val _ = send (receiver, result)
           in loop ()
           end
   in
     loop ()
   end
   #+end_src
   Ignoring the (bigger) issue that the function call might result in a run-time error, an adversary can terminate p using a link:
   #+begin_src sml :eval no
   let val kill_pid    = spawn(fn () => receive [ hn "die" => 1 / 0 ])
       fun kill_fun () = link kill_pid (* Evaluating kill_fun () establishes the link to kill_pid *)
       val mypid       = self ()
       val _           = send (p, (kill_fun, (), mypid))
   in
     (* wait for a sufficient amount of time... *)
     send (kill_pid, "die") (* Signal kill_pid to terminate itself, killing p *)
   end
   #+end_src

5. The ability to terminate arbitrary processes also directly enables a denial-of-service attack by killing off processes, which is a problem in a scenario where some process acts as some sort of server, and it's ID is broadcast to potentially untrusted nodes.

*** Securing links, monitors and process termination (API, v2)

Addressing the security related issues identified [[#issues-with-v1][with version v1 of the API]].

Both monitoring and linking can be seen as a "delayed" form of (indirect) message passing:
- Monitoring/ linking to a process conceptually results in that process sending a termination signal/message to the monitor/linker, "just before it terminates"
- Monitors must /explicitly/ receive it by inspecting the mailbox (calling ~receive~ with an appropriate handler)
- Links /implicitly/ receive it, at any point in the program, circumventing the mailbox
- If the terminating process is in secret context (PC/blocking level), e.g. by branching on a secret value, it must be prevented from sending termination signals/messages to public processes, i.e. 'no write down'

Additionally, linking and forcefully terminating a process (i.e. calling ~terminate~ it) can (unexpectedly) interrupt the control flow at any point in a program, which is potentially publicly observable.

**** Linking

A challenge in dealing with leaks through linking is that by the time the violation is identified, it's already "too late": We do not know ahead of time the context in which a process will terminate, and by the time the runtime kills the linker, information may have already leaked through the progress channel.

One way to address this is to modify the ~link~ function to also take a confidentiality level, say l_{1}, in addition to the ID of the linkee, and calling the function raises the blocking level of the caller to at least l_{1}. When the linkee terminates with blocking level l_{2}, the termination signal/message will only be "received" by the linker, something that happens implicitly, if l_{2} ⊑ l_{1}, i.e. /a public process is allowed to send information to a secret process, and the secret process is allowed to read it/.
To summarize, the v2 API for ~link~ now looks like this:

~link : (pid, lvl) -> ()~: Establish a link between the caller (the linker) to the process with ID ~pid~ (the linkee) at confidentiality level ~lvl~.
If the linkee terminates with blocking level l, the linker will also terminate /iff/ l ⊑ ~lvl~.
If ~lvl~ ⊏ l, the link is silently dropped without terminating the linker.

*Revisiting the link example*: With this version of ~link~, the type of leak illustrated in [[#sec-api-v1-issues][the previous section]] is prevented:
#+begin_src sml :eval no
(* Code of process p *)
let ...
in
   if secret then
     1 / 0
   else
     (* code that doesn't cause p to diverge *)
end

(* ... *)

(* Code of process q1 *)
let val _ = link (p, l)
    fun loop i =
        let val _ = send (q2, i)
        in loop (i + 1)
        end
in
  loop 0
end
#+end_src
- ~link (p, l)~ raises the blocking level of q_{1} to at least l
- There are three scenarios:
  - If q_{2} is on a remote node trusted up to level l', then q_{1} is terminated with an IFC violation before it can send anything to q_{2}, unless l ⊑ l'.
  - If q_{2} is a local process, then the message is tainted with blocking level (at least) l, and the restrictions on receiving messages apply.
  - If l ⊑ l_{secret} then q_{1} will loop forever.
    In this case, it's not possible to distinguish whether the divergence is due to p diverging, or due to the confidentiality level of the link being too low.

An unfortunate side effect of this modification of ~link~ is that the guarantees that programmers get on linking are "weakened", relative to systems/languages whose primary concern is not IFC (e.g. Erlang):
Whether the linker (the caller of ~link~) will be terminated when the linkee (the argument supplied to the ~link~ call) terminates, depends on the PC/blocking level of the linkee, and this might evolve unexpectedly.
The link can be established at a very high level, to be more reliable, but this also comes with cost of raising the blocking level of the linker, which is a problem in practice.
This can be (mostly) remedied, if the programmer is willing to explicitly declassify the blocking level after establishing the link.

**** Monitoring

To ensure that information about the execution context (e.g. which branches have been taken) of a process
is not leaked /directly/ via monitoring, it is necessary to taint the termination message that is broadcast
to monitors with the blocking level of the process, at the point of termination.
Additionally, the ~monitor~ primitive can be modified to take a confidentiality level, similarly to the modification of ~link~, such that monitors are required to "pre-commit" to the level of termination messages they are allowed to receive.
To summarize, the v2 API for ~monitor~ now looks like this:

~monitor : (pid, lvl) -> monRef~:
Establish a monitoring relationship between the caller (the monitor) and process with ID ~pid~ at confidentiality level ~lvl~.
The call returns a monitor reference that uniquely identifies the monitoring relationship.
If the process being monitored terminates with blocking level l, the monitor will be sent a termination message /iff/ l ⊑ ~lvl~.
If ~lvl~ ⊏ l, the monitoring relation is dropped silently.
The confidentiality level of the (contents of the) termination message, e.g. the termination reason, is raised to level l.

*Revisiting the monitoring example:* With this version of ~monitor~, direct leaks through ~receive~ as illustrated in [[#sec-api-v1-issues][the previous section]] are prevented:
#+begin_src sml :eval no
(* Code of process p *)
let ...
in
  if secret then (* Branching on the secret conditional raises the blocking level  *)
    1 / 0        (* Termination in either branch therefore results in broadcasting *)
  else           (* a secret message to all monitors of the process                *)
    ()
end

(* ... *)

(* Code of process q *)
let val monref = monitor (p, l)
in
  receive [
    hn ("DOWN", monref', pid, "NORMAL") => print "So it was false, huh",
    hn ("DOWN", monref', pid, err)      => print "So it was true, huh"
  ]
end

#+end_src
- q is only guaranteed to receive a message if l_{secret} ⊑ l
- In order for q to receive the message, its PC level must be l_{secret}.
  This restricts it from communicating with any public processes.
  Alternatively, q must explicitly obtain clearance to raise/lower the mailbox, and possibly also have enough authority to declassify the PC/blocking level.
- If q is on a remote untrusted node, then the message is blocked.

Similar to linking, this slightly "weakens" the guarantees on the monitoring relationship, in the sense that whether a termination message is delivered depends on the PC/blocking level of a process, which might evolve unexpectedly throughout program execution, although this can also be remedied through explicit declassification.

**** Monitoring or linking to a dead process 

Another question is how to handle when a process tries to monitor or link to a process no longer exists (or never existed).
In Erlang, this has the same effect as triggering the effect of the monitor/link, as if the process had just terminated:
- A process trying to establish a link to a dead process will receive an exit signal, causing it terminate (if it is not trapping exit signals)
- A process trying to monitor a dead process will receive a notification. The reason for termination given in the notification is ~noproc~, i.e. the runtime has no knowledge of the process.
- Additionally, the above is also what happens if the process resides on a remote Erlang node that cannot be reached, i.e. there is no connection.

This behavior is useful in scenarios where a failure may have occurred as part of the spawning/initialization of a new process, and other processes, e.g. the parent/supervisor, has not had a chance to establish the monitor/link yet. 

Safely handling this requires a little extra care.
In cases where an adversary has obtained the ID of a process that may have already terminated in a secret context, any retroactive effects of trying to link/monitor it should be subject to the same restrictions as if the process is still alive:
If the confidentiality level of the link/monitor is not high enough, there should be no observable effect.
As an example, consider a process p running the code
  #+begin_src sml :eval no
  if secret then
    ()
  else
    let fun loop () =
            loop ()
    in
      loop ()
    end
  #+end_src
Assume that another process q has the ID of p and waits a sufficient amount of time that p (with high probability) has had a chance to run, and then tries to monitor p, at level l.
Whether p is still alive depends on the value of ~secret~.
Suppose ~secret = true~, then q is only allowed to know that p has terminated if ~labelOf(secret)~ ⊑ l.

To accurately enforce this, it is necessary to keep information about which processes have terminated and in what context.
This is not practical in a real system that may be running indefinitely, as it may eventually exhaust the available memory/storage capacity, and opens the door for denial-of-service attacks for the same reason.

It would be sound, from an IFC perspective, to just silently ignore requests to link/monitor a dead/unknown process regardless of the confidentiality level provided (perhaps with the exception of something like the highest level ⊤), but this may make the link/monitor less useful in practice, e.g. in a supervision setting.

If supervision is the main use case, where it's important to catch and respond to failures may happen in the spawn/initialization phase, then a compromise may be keep information about dead processes around for a limited amount of time, and make this configurable per node.
When the information about a dead process is eventually forgotten, link/monitor request may be silently ignored.

**** TODO Termination

- Termination is a very powerful action: It poses both a confidentiality and availability issue, if any process is allowed to terminate any other process, as identified in the [[#issues-with-v1][issues with version v1 of the API]].
- If the main use case is supervision, it is reasonable to somehow provide the supervisor/parent of a process with the ability to terminate a child.
- Instead of exposing a termination primitive, this can be achieved by programming a "kill switch" as part of the spawning process, using the ~link~ primitive, as sketched below


#+begin_src sml :eval no
let val nonce = mkuuid ()
    fun kill_switch () = receive [ hn ("KILL", n) when n = nonce => () ]
    val kill_switch_pid = spawn kill_switch
    val child_pid = spawn (fn () =>
                              (* Assume that l is the current PC/blocking level, and that
                                 the PC/blocking level of the child stays at level l
                                 (otherwise, if sufficient authority is available the
                                 blocking level could be declassified after the link is
                                 established) *)
                              let val _ = link (kill_switch_pid, l)
                              in
                                (* ... *)
                              end)
in
  (* ... *)
  send (kill_switch_pid, ("KILL", nonce)) (* Terminate the child *)
end
#+end_src
Given this, it may makes sense to simplify the API by not including a ~terminate~ primitive, for now.

**** TODO Cross-node monitoring/linking requests

- /Outgoing/ monitor/link request: If process p in context l_{p}, wants to monitor/link to process q on node n, and node n is trusted to level l_{n}, only allow the /outbound/ request if l_{p} ⊑ l_{n} (additionally also take the level of the monitor/link into account), otherwise terminate with IFC violation (since it's equivalent to sending a message)

- /Incoming/ monitor/link request: If node n with trust level l_{n}, wants to monitor/link to local process p, only honor the request (i.e. send the termination signal/message back) if p terminates in context l_{p} such that l_{p} ⊑ l_{n} (additionally also take the level of the monitor/link into account)

* Resources

- "Programming Erlang" (2nd Edition), Armstrong, 2013
- [[https://dl.acm.org/doi/10.1145/1863509.1863514][A unified semantics for future Erlang]], Svensson, Fredlund & Benac-Earle, 2010
- [[https://haskell-distributed.github.io/static/semantics.pdf][Cloud Haskell Semantics (draft pdf)]]
- [[https://ieeexplore.ieee.org/abstract/document/1212703][Observational determinism for concurrent program security]], Zdancewic & Myers, 2003
- [[https://ieeexplore.ieee.org/abstract/document/5207637][Noninterference for a practical DIFC-based operating system]], Krohn & Tromer, 2009
- Technical documentation
  - [[https://www.erlang.org/doc/system/][Erlang system documentation]]
  - [[http://haskell-distributed.github.io/][Cloud Haskell documentation/tutorials]]
  - [[https://doc.akka.io/libraries/akka-core/current/general/index.html][Akka documentation]]
