#+TITLE: Process supervision and monitoring in Troupe
#+STARTUP: fnadjust
#+OPTIONS: toc:3


* Introduction
:properties:
:custom_id: sec-troupe-supervision-introduction
:end:

Troupe is a programming language for concurrent and distributed programming with dynamic information flow control.
As a research language, Troupe is focused on exploring new approaches to ensuring secure information flow in decentralized, multi-party systems.

One key limitation of the current Troupe design is the lack of a /supervision/ mechanism, the ability for processes to monitor and respond to the termination of other processes.
This limits the ability to handle and recover from unexpected failures, which is crucial for building reliable and fault-tolerant distributed applications.

This design document serves as an overview for integrating a security aware supervision mechanism into the Troupe language.
The intent is to identify requirements and challenges, including security considerations, and explore possible designs of such a mechanism, with the goal of developing an MVP (minimum viable product; prototype).
The supervision mechanism will enable processes to selectively monitor the lifecycle of other processes, detect failures, and implement custom recovery logic,
while preserving Troupe's security guarantees.

** Motivation

- *Error handling and recovery*: Improve the reliability of Troupe programs by monitoring for and handling unexpected failure of processes. 
- *Separation of concern*: Separate core application (business) logic from failure handling logic for more modular program design.
- *Fault tolerance*: Isolate the failure of system components by automatically restarting or replacing them, maintaining overall availability of the system.

** Requirements

An effective and reliable supervision monitoring mechanism must, at minimum, satisfy the following functional properties:
1. The mechanism must be able to accurately and promptly detect process failure to be able to respond appropriately to them as they occur.
2. The mechanism must be able to forcefully terminate supervised processes, e.g. in order to reset a system component to a stable state.
4. The mechanism must apply on both an intra- and inter-node level.
5. The mechanism must not compromise confidentiality or violate the progress-sensitive noninterference security policy.

** Challenges

*** Security considerations.

1. *Information leakage*: The ability to detect termination events introduces new channels for information leakage. For example, if a lower-security process is able to detect the termination of a higher-security process, this could reveal information about the internal state or behavior of the higher-security process, compromising confidentiality.
2. *Covert channels*: A termination notification channel has the potential to act as a covert channel that allows bypassing the intended information flow control restrictions. 
3. *Denial of service*: A supervision mechanism could be vulnerable to denial of service attacks, for example by repeatedly creating and terminating processes.

*** Practical considerations

1. *Efficiency*: Minimize performance and networking overhead related to supervision.
2. *Portability*: Minimize reliance on system/networking specifics (implement as much of the functionality as possible in Troupe itself).
3. *Usability*: Reduce the cognitive overhead related to using the mechanisms.

** Approach

The current message passing mechanism alone cannot be relied on for a number of reasons.
First, processes may terminate unexpectedly due to e.g. run-time errors, meaning that they are not able to send a message to their supervisor before terminating, and processes must be aware that they are supervised to receive termination request from supervisors.
Further, there is no way to guarantee that a supervisee is terminated if the supervisor terminates unexpectedly, leading to orphaned processes.

Take inspiration from Erlang and Akka.
Both of these languages adopt a "let it crash" philosophy; business logic code should not be concerned with handling /unexpected failures/.
The responsibility of this is delegated to another component.
This is known as the /supervision principle/.

Erlang's approach to error handling and the supporting language features are described in [[#sec-erlang-error-handling][this section]].

Use the low-level features to implement libraries.

** Use cases

- Restarting processes that have failed unexpectedly
- Terminating 'stuck' or unresponsive (e.g. due to corrupt internal state) processes
- Building supervision trees/ hierarchies
- Monitoring the termination of other processes, also for normal termination for event processing (OBS: this can already be done programmatically)

** Evaluation

There are several key criteria to consider when evaluating a possible design
1. Security assurance
   1. Does not introduce new ways to leak information or covert channels; does not violate progress-sensitive noninterference
   2. Robust against denial of service attacks/ availability vulnerabilities
2. Expressiveness and flexibility
   1. Handles different failure scenarios and recovery strategies
   2. Supports supervision at different levels of granularity
3. Usability and ergonomics
   1. Ease of use of supervision-related APIs/constructs
   2. Integrates with the rest of Troupe's programming model
4. Performance and scalability
   1. Minimizes performance overhead on supervised processes
   2. Handles a large number of concurrent supervision relationships without impacting the rest of the system
5. Alignment with Troupe's design principles
   1. Integration with Troupe's existing security model and mechanisms

When evaluating design proposals, it's important to weigh these criteria against each other and consider the trade-offs involved. For example, a design that maximizes security assurance may come at the cost of reduced expressiveness or usability. 
For example, a design that maximizes security assurance may come at the cost of reduced expressiveness or usability.

* Error handling in Erlang
:properties:
:custom_id: sec-erlang-error-handling
:end:

This section describes the approach to error handling in Erlang.
The main supporting language feature is the ability to link processes together, along with the concept of exit signals and system processes.

Based on:
- The [[https://www.erlang.org/doc/system/readme.html][Erlang system documentation]], specifically the sections on [[https://www.erlang.org/doc/system/robustness.html#error-handling][error handling]], [[https://www.erlang.org/doc/system/design_principles.html][OTP design principles]] and the [[https://www.erlang.org/doc/system/sup_princ.html][supervisor behavior]].
- The book /Programming Erlang/ by Joe Armstrong.

** Links, exit signals and system processes

This section describes the concepts of exit signals, process linking and system processes.

*** Illustrating links and exit signals
:properties:
:header-args: :tangle ./erlang-examples/linkdemo.erl
:end:

This section contains Erlang code examples that demonstrates how process linking works in Erlang.
The examples are based on the book Programming Erlang by Joe Armstrong.

We define a new module
#+BEGIN_SRC erlang
-module(links).
#+END_SRC

We define three processes A, B and C
#+BEGIN_SRC erlang
processA() ->
  process_flag(trap_exit, true),
  wait_for_message('A').

processB(A, TrapFlag) ->
  process_flag(trap_exit, TrapFlag),
  link(A),
  wait_for_message('B').

processC(B, Exit) ->
  link(B),
  case Exit of
    {"die", Reason} ->
      exit(Reason);
    {"divide", N} ->
      1/N,
      wait_for_message('C');
    normal ->
      true
  end.
#+END_SRC

We define a function ~wait_for_message~ that awaits a message and prints it
#+BEGIN_SRC erlang
wait_for_message(Name) ->
  receive
    Message ->
      io:format("Process ~p received the message ~p~n", [Name, Message]),
      wait_for_message(Name)
  end.  
#+END_SRC

Finally, we define a function that queries the status of a process
#+BEGIN_SRC erlang
status(Name, Pid) ->
  case erlang:is_process_alive(Pid) of
    true -> 
      io:format("Process ~p (~p) is alive~n", [Name, Pid]); 
    false -> 
      io:format("Process ~p (~p) is dead~n", [Name, Pid])
  end.
#+END_SRC

** The supervision principle

This section describes Erlang's supervision principle.

*** A simple hand rolled supervisor
:properties:
:header-args: :tangle ./erlang-examples/simple_supervisor.erl
:end:

This section contains Erlang code examples that demonstrate how process linking can be used for error handling by writing a simple, generic supervisor process.

#+BEGIN_SRC erlang :noweb-ref simple_supervisor
-module(simple_supervisor).

start_children([], Children) -> Children;
start_children([{Start}|Rest], Children) ->  
  Child_pid = spawn_link(Start),
  start_children(Rest, maps:put(Child_pid, {Start}, Children)).

kill_child(Child_pid) ->
  exit(Child_pid, kill),
  receive
    {'EXIT', Child_pid, _} ->
      ok
  end.

terminate_children(Children) ->
  maps:foreach(fun (Pid, _) -> kill_child(Pid) end, Children).

supervisor_handle_termination(Pid, {Strategy, Child_specs, Children}) ->
  case maps:find(Pid, Children) of
    {ok, Child_spec} ->      
      case Strategy of
        "one_for_all" ->
          ok = terminate_children(maps:remove(Pid, Children)),
          New_children = start_children(Child_specs, maps:new()),
          {ok, {Strategy, Child_specs, New_children}};
        "one_for_one" ->
          New_children = start_children([Child_spec], maps:remove(Pid, Children)),
          {ok, {Strategy, Child_specs, New_children}}
      end;
    _ ->
      {ok, {Strategy, Child_specs, Children}}
  end.

supervisor_loop(State) ->
  receive
    {'EXIT', Pid, Reason} ->
      io:format("Received exit signal from child with reason ~w~n", [Reason]),
      {ok, New_state} = supervisor_handle_termination(Pid, State),
      supervisor_loop(New_state)
  end.

simple_supervisor(Strategy, Child_specs) ->
  process_flag(trap_exit, true),
  Children = start_children(Child_specs, maps:new()),
  State = {Strategy, Child_specs, Children},
  supervisor_loop(State).
#+END_SRC

*** The standard library supervisor module

This section contains Erlang code examples that demonstrate use of the supervisor behavior from Erlang's standard library.

* Design
:properties:
:custom_id: sec-troupe-supervision-design
:end:

This section describes the design of a process linking mechanism.

** Challenges

This section describes the challenges and pitfalls of designing a security-aware process linking mechanism, and exposing it to programmers.

It is not entirely obvious how to translate the concepts of linking processes and exit signals from Erlang to a noninterference context. 
Erlang-style linking introduces another information channel, since the emission of exit signals may leak information via the program control context, or even directly, if arbitrary Troupe values can be passed as exit reasons.

Elevating a process to a system process by allowing it to trap exit signals.

For example, if a program only crashes if a specific branch is taken, linked processes trapping exits can gain information about which branch was taken.
Furthermore, two processes may be linked both directly and indirectly, as exit signals are propagated; the link relation is transitive.

Encoding a secret through process linking.

Similar to the mailbox, the set of linked processes and the signal queue, and possibly whether or not a process is trapping exit signals, are /mutable state/.

** Possible designs

This section describes design possibilities/ design iterations for a process linking mechanism.


*** Imagined use

Linking two processes and trapping exit signals
#+BEGIN_SRC sml
let fun piggybank balance =
        [ hn ("deposit", amount) =>
          piggybank (balance + amount),

          hn ("smash", receiver) =>
          send (receiver, ("piggybank smashed", balance)),

          hn ("balance", receiver) =>
          let val _ = send ("piggybank balance", balance),
          in piggybank balance
          end
        ]

    (* Allow the curernt process to trap exit signals *)
    val _ = process_flag("TRAP_EXIT", true)

    (* Spawn the piggy bank process and link to it *)
    val piggybank_pid = spawn (fn () -> piggybank 0)
    val _ = link piggybank_pid
in
  (* Wait for an exit signal from the piggy bank *)
  receive [
    hn ("EXIT", pid, reason) when pid = piggybank_pid =>
    print ("Piggy bank process (" ^ (toString piggybank_pid) ^ ") terminated with reason " ^ (toString reason))
  ]
end
#+END_SRC
- The ability to link two processes (from either end) using a built-in function provided by the Troupe runtime
- The ability to trap exit signals, and receive them as normal messages


A process that reads something from stdin, that then needs to be terminated?
A ping-pong example?
#+BEGIN_SRC sml
import timeout

let fun processA () =
        let val (counter, key, sender) = receive [ hn x => x ]
            val _ = send (sender, (counter + 1, key))
        in processA ()
        end

    fun processB () = 
        let val A = spawn processA
            val _ = link A
            val key = mkuuid () 
            val _ = send (A, (0, key, self()))
            fun loop () =
                let val nonce = mkuuid ()
                    val _ = spawn (fn () => timeout (self ()) nonce 2500)
                in
                  receive [ hn x when x = nonce => exit (A, "TIMEOUT"),
                            
                            hn (counter, k) when k = key =>
                            let val _ = send (A, (counter + 1, key, self()))
                            in loop ()
                            end
                          ]
                end
        in loop ()
        end

in
  processB ()
end
#+END_SRC
- The ability to send an exit signal to a process to forcefully terminate it (when would this be useful? if a process gets stuck somehow...)

*** A first (naive) solution

- Add built-in functions that are Troupe analogs of Erlang's link primitives, with similar semantics.
- No restrictions on linking process, trapping or sending exit signals.
- There is no way to query the set of linked processes.
- Processes are unaware that they are being linked.
- Broadcasting an exit signal taints it with the confidentiality level of the program context and the reason value.
- Exit trapping processes must explicitly raise their mailbox to receive notices of termination.
- A run-time violation of non-interference through inter-node broadcast of exit signals terminates all links between the affected nodes.


Evaluation:
- Availability concerns: Malicious processes can crash other processes through links or exit signals.
- Confidentiality concerns: Information may leak.
- Ambient authority: Any processes is allowed to elevate itself to a system process (trap exit signals). 

*** Restricting linking via capabilities

- Restrict the ability to link, trap and send exit signals by requiring a capability.
- The capability can be obtained through 2 means:
  - The process that spawns the process obtains a capability to link to it.
  - The process itself has a capability, obtained when it is spawned (which it may give to other processes).


Evaluation:

*** Other possibilities

- Require both the capability of the linker and linkee when linking (since a link is bi-directional)
- Define exit trapping per process and require a capability
- Put a ceiling on the security level of a link

** Arguing noninterference of the designs

When evaluating, consider whether there is ambient authority or mutable state involved.
