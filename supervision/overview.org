#+TITLE: Process supervision and monitoring in Troupe
#+STARTUP: fnadjust

This design document serves as an overview for integrating a security aware supervision mechanism into the Troupe language.
The intent is to identify requirements and challenges, including security considerations, and explore possible designs of such a mechanism, with the goal of developing an MVP (minimum viable product; prototype).
The supervision mechanism will enable processes to selectively monitor the lifecycle of other processes, detect failures, and implement custom recovery logic,
while preserving Troupe's security guarantees.

* Table of contents
:properties:
:visibility: all
:end:

- [[#sec-introduction][Introduction]]
  - [[#sec-motivation][Motivation]]
  - [[#sec-requirements][Requirements]]
  - [[#sec-challenges][Challenges]]
  - [[#sec-evaluation-criteria][Evaluation criteria]]
- [[#sec-approach][Approach]]

* Introduction
:properties:
:custom_id: sec-introduction
:end:

Troupe is a programming language for concurrent and distributed programming with dynamic information flow control.
As a research language, Troupe is focused on exploring new approaches to ensuring secure information flow in decentralized, multi-party systems.

One key limitation of the current Troupe design is the lack of a /supervision/ mechanism, the ability for processes to monitor and respond to the termination of other processes.
This limits the ability to handle and recover from unexpected failures, which is crucial for building reliable and fault-tolerant distributed applications.


** Motivation
:properties:
:custom_id: sec-motivation
:end:

- *Error handling and recovery*: Improve the reliability of Troupe programs by monitoring for and handling unexpected failure of processes.
- *Separation of concern*: Separate core application (business) logic from failure handling logic for more modular program design.
- *Fault tolerance*: Isolate the failure of system components by automatically restarting or replacing them, maintaining overall availability of the system.

** Requirements
:properties:
:custom_id: sec-requirements
:end:

An effective and reliable supervision monitoring mechanism must, at minimum, satisfy the following functional properties:
1. The mechanism must be able to accurately and promptly detect process failure to be able to respond appropriately to them as they occur.
2. The mechanism must be able to forcefully terminate supervised processes, e.g. in order to reset a system component to a stable state.
4. The mechanism must apply on both an intra- and inter-node level.
5. The mechanism must not compromise confidentiality or violate the progress-sensitive noninterference security policy.

** Challenges
:properties:
:custom_id: sec-challenges
:end:

*** Security considerations.

1. *Information leakage*: The ability to detect termination events introduces new channels for information leakage. For example, if a lower-security process is able to detect the termination of a higher-security process, this could reveal information about the internal state or behavior of the higher-security process, compromising confidentiality.
2. *Covert channels*: A termination notification channel has the potential to act as a covert channel that allows bypassing the intended information flow control restrictions.
3. *Denial of service*: A supervision mechanism could be vulnerable to denial of service attacks, for example by repeatedly creating and terminating processes.

*** Practical considerations

1. *Efficiency*: Minimize performance and networking overhead related to supervision.
2. *Portability*: Minimize reliance on system/networking specifics (implement as much of the functionality as possible in Troupe itself).
3. *Usability*: Reduce the cognitive overhead related to using the mechanisms.

** Evaluation criteria
:properties:
:custom_id: sec-evaluation-criteria
:end:

1. Security assurance
   1. Does not introduce new ways to leak information or covert channels; does not violate progress-sensitive noninterference
   2. Robust against denial of service attacks/ availability vulnerabilities
2. Expressiveness and flexibility
   1. Handles different failure scenarios and recovery strategies
   2. Supports supervision at different levels of granularity
3. Usability and ergonomics
   1. Ease of use of supervision-related APIs/constructs
   2. Integrates with the rest of Troupe's programming model
4. Performance and scalability
   1. Minimizes performance overhead on supervised processes
   2. Handles a large number of concurrent supervision relationships without impacting the rest of the system

Consider trade-offs, e.g. a design that maximizes security assurance may come at the cost of reduced expressiveness or usability.

* Approach
:properties:
:custom_id: sec-approach
:end:

The current message passing mechanism alone cannot be relied on for a number of reasons.
First, processes may terminate unexpectedly due to e.g. run-time errors, meaning that they are not able to send a message to their supervisor before terminating, and processes must be aware that they are supervised to receive termination request from supervisors.
Further, there is no way to guarantee that a supervisee is terminated if the supervisor terminates unexpectedly, leading to orphaned processes.

- Inspirations for supervision functionality
  - [[https://www.erlang.org/][Erlang]] relies heavily on termination signals and the process linking/monitoring mechanisms for error handling, including the implementation of supervision
  - [[http://haskell-distributed.github.io/][Cloud Haskell]] has almost the same linking/monitoring mechanisms as Erlang, except that the semantics are slightly simpler, since process linking is unidirectional
  - [[https://akka.io/][Akka]] also uses a flavor of the linking and monitoring ("watching") approach
- Introduce a minimal supervision API, consisting of some built-in functions, inspired by the above
  - ~link~: Create a unidirectional /link/ between the current process (the "linker") and another process (the "linkee"); when the linkee terminates, so does the linker, but not the other way around.
  - ~monitor~: Create a unidirectional /monitor/ between the current process and another process; when the process being monitored terminates, the current process will receive a message (in the mailbox) with the reason (a Troupe value) for termination
  - ~terminate~: Unconditionally terminate a given process (including the current process) with a given reason (to enable a supervising process to kill a non-responsive or rogue/ malfunctioning child)
- These primitives can be used to build supervision behavior (NOTE: Pseudo-example/ imagined use, not final API/ semantics):
  #+BEGIN_SRC sml
  let fun supervise child_fun =
          let val sup_pid = self()
              val child_pid = spawn (fn () =>
                                let val _ = link sup_pid
                                in child_fun ()
                                end)
              val mon_ref = monitor child_pid
          in
            receive [
              hn ("EXIT", ref, pid) when ref = mon_ref => ...
            ]
          end
  in
    ...
  end
  #+END_SRC
- Additionally, they can function as a form of an exception + try/catch mechanism (with the overhead of spawning new processes) (NOTE: Pseudo-example/ imagined use, not final API/ semantics):
  #+BEGIN_SRC sml
  let fun try nonce f =
          receive [ hn ("START", n) when n = nonce =>
                    let val result = f ()
                    in terminate (self(), ("NORMAL", result))
                  ]

      fun catch ref ex_handler =
          receive [
            hn ("EXIT", ref', pid, reason) when ref' = ref =>
            case reason of
                ("NORMAL", result) => result
              | _ => ex_handler reason
          ]
      fun try_catch f ex_handler =
          let val nonce = mkuuid ()
              val try_pid = spawn (fn () => try nonce f)
              val mon_ref = monitor try_pid
              val _ = send (try_pid, ("START", nonce))
          in catch mon_ref ex_handler
          end
  in
    ...
  end
  #+END_SRC

