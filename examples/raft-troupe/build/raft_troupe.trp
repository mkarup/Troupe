import lists

let 
    (* Constants *)
    val WAIT = "WAIT"
    val SUS = "SUS"
    val DONE = "DONE"
    val SEND_HEARTBEAT = "SEND_HEARTBEAT"
    val RAFT_UPDATE = "RAFT_UPDATE"
    val NOT_LEADER = "NOT_LEADER"
    val ACKNOWLEDGE = "ACKNOWLEDGE"
    val REJECT = "REJECT"
    val ELECTION_TIMEOUT = "ELECTION_TIMEOUT"
    val REQUEST_VOTE = "REQUEST_VOTE"
    val YES_VOTE = "YES_VOTE"
    val NO_VOTE = "NO_VOTE"
    val VOTE_TIMEOUT = "VOTE_TIMEOUT"
    val APPEND_ENTRIES = "APPEND_ENTRIES"
    val SNAPSHOT = "SNAPSHOT"
    val ADD_NODES = "ADD_NODES"
    val DIAL = "DIAL"
    val DIALER_ACK = "DIALER_ACK"
    val DIALER_SM_BUSY = "DIALER_SM_BUSY"
    val DIALER_SM_DONE = "DIALER_SM_DONE"
    val DIALER_CLIENT_MSG = "DIALER_CLIENT_MSG"
    val DIALER_MESSAGE_TIMEOUT = "DIALER_MESSAGE_TIMEOUT"
    val DIALER_BUSY_TIMEOUT = "DIALER_BUSY_TIMEOUT"
    val SEND_TO_NTH = "SEND_TO_NTH"
    val SEND_TO_ALL = "SEND_TO_ALL"
    val DEBUG_PRINTLOG = "DEBUG_PRINTLOG"
    val DEBUG_PAUSE = "DEBUG_PAUSE"
    val DEBUG_CONTINUE = "DEBUG_CONTINUE"
    val DEBUG_APPLYSNAPSHOT = "DEBUG_APPLYSNAPSHOT"
    val DEBUG_SNAPSHOT_COND = "DEBUG_SNAPSHOT_COND"
    val DEBUG_TIMEOUT = "DEBUG_TIMEOUT"
    val FUNCTION_DONE = "FUNCTION_DONE"
    val ERROR_TIMEOUT = "ERROR_TIMEOUT"
    val CLUSTER = "CLUSTER"
    val CLIENT = "CLIENT"

    fun not a = a = false
    val contains = elem
    fun send_to_all processes msg sender = map (fn x => send(x, msg)) (filter (fn x => x <> sender) processes)

    fun send_to_nth processes msg n = send((nth (reverse processes) n), msg)

    fun max a b = if a < b then b else a 

    fun min a b = if a > b then b else a

    (* #IMPORT libs/quickselect.trp *)
    fun is_even i = i mod 2 = 0

    (* Using QuickSelect, finds the kth element of a list. *)
    fun quickselect list k = 
        case list of
        [] => "ERROR: Empty list"
        | h :: t =>
            let val (ys, zs) = partition (fn x => x > h) t
                val l = length ys
            in
                if k < l then quickselect ys k
                else if k > l then quickselect zs (k-l-1)
                else h
            end

    (* Returns the median of a list. *)
    fun median list = 
        let val len = length list
            val middle = if is_even len then len / 2 - 1 else (len - 1) / 2
        in quickselect list (middle)
    end
    (* END OF libs/quickselect.trp *)

    (* #IMPORT libs/log.trp *)
    (* Creates a snapshot. *)
    fun set_snapshot snapshot index term = {
        snapshot = snapshot,
        lastIncludedIndex = index,
        lastIncludedTerm = term
    }

    (* Creates a default, empty snapshot. *)
    val empty_snapshot = {
        snapshot = (),
        lastIncludedIndex = 0,
        lastIncludedTerm = 0
    }

    (* A default, empty log. *)
    val empty_log = {
        log = [],
        snapshot = empty_snapshot,
        lastApplied = 0,
        commitIndex = 0,
        lastMessageSerial = ""
    }

    fun pretty_print_log id log = 
        (* Disabled for library *)
        (* printString "\n========******========";
        print (length log.log);
        printString ("ID: "^id);
        printString "----------------------";
        printString "Entries (term, message):";
        map (fn x => print (x.term, x.command)) log.log;
        printString "----------------------";
        printString "CommitIndex:";
        print log.commitIndex;
        printString "LastApplied:";
        print log.lastApplied;
        printString "----------------------";
        printString "Snapshot:";
        print log.snapshot;
        printString "========******========\n";*)
        ()

    (* Appends a message to the log, and notes the message's serial number. *)
    fun append_message log message callback term serial = 
        let val new_entry = {
            term = term,
            command = message,
            callback = callback,
            serial = serial
        }
        in {
            log with
            lastMessageSerial = serial, 
            log = new_entry :: log.log
        } 
    end


    (* Appends a list of message to the log. *)
    fun add_entries_to_log log entries term =
        case entries of
        [] => log
        | h :: t => 
            add_entries_to_log (append_message log h.command h.callback term h.serial) t
            h.term

    (* Updates the lastApplied-index. *)
    fun update_applied log = {
        log with
        lastApplied = log.lastApplied + 1
    }
    
    (* Commits a message in the log. *)
    fun update_commit log new_index = {
       log with 
       commitIndex = (max new_index log.commitIndex)
    }

    (* Rolls the log back one entry. *)
    fun rollback_log log =
        let val loglog = log.log
    in case loglog of
    (_ :: prev_log) => {
        log with 
        log = prev_log
    }
    | [] => {log with log = []}
    end

    (* Get the entry of the latest log entry. *)
    fun get_log_index log = (length log.log) + log.snapshot.lastIncludedIndex

    (*Determines whether or not all log changes have been committed. *)
    fun log_is_committed log = (get_log_index log = log.commitIndex)

    (* Rolls the log back n time. *)
    fun rollback_log_to log n = 
        if n < (get_log_index log) then
            let val log = rollback_log log
            in (rollback_log_to log n)
        end
        else log

    (* Get the term of the latest entry of the log, or, if empty, the last
    included index of the snapshot. *)
    fun get_latest_entry_term log =
        case log.log of
        [] => log.snapshot.lastIncludedTerm
        | h :: _ => h.term

    (* Get the term of the latest log entry. *)
    fun get_latest_log_term log = get_latest_entry_term log

    (* Get the message of the latest log entry. *)
    fun get_latest_log_command log = 
        case log.log of
        [] => 0 (* Should not be reachable. *)
        | h :: _ => h.command

    fun get_nth_command log index = nth (reverse log.log) (index - log.snapshot.lastIncludedIndex) 

    (* Returns a slice of all entries after log-index n. *)
    fun get_commands_after_nth entries n last_included =
        let val log_slice = slice (n - last_included) (length entries) (reverse entries)
        in log_slice
        end

    (* Get a snapshot of all committed entries. *)
    fun get_snapshot state log = 
        if log.commitIndex > 0 andalso 
        (log.commitIndex - log.snapshot.lastIncludedIndex) <= length log.log then
            let val lastCommitted = get_nth_command log log.commitIndex
            in set_snapshot state log.commitIndex lastCommitted.term end
        else empty_snapshot
        

    (* Applies a snapshot to the log. *)
    fun apply_snapshot snapshot log =
        let val newCommitIndex = 
                if log.commitIndex < snapshot.lastIncludedIndex then snapshot.lastIncludedIndex
                else log.commitIndex
            val uncommitted_entries = get_commands_after_nth log.log newCommitIndex log.snapshot.lastIncludedIndex
            val newLastApplied = 
                if log.lastApplied < snapshot.lastIncludedIndex then snapshot.lastIncludedIndex
                else log.lastApplied
        in { log with 
                log = uncommitted_entries,
                commitIndex = newCommitIndex,
                lastApplied = newLastApplied,
                snapshot = snapshot }
    end

    (* Asks the state-machine whether or not to snapshot. *)
    fun evaluate_snapshot_cond state snapshot_cond log =
        if (log.lastApplied - log.snapshot.lastIncludedIndex) > snapshot_cond then
            apply_snapshot (get_snapshot state log) log
        else log
    (* END OF libs/log.trp *)

    (* #IMPORT libs/leader-info.trp *)

    (* Generates a default leader info, with the nextIndex of all followers
    being the nextIndex of the new leader. This can be changed with followers
    rejecting AppendEntries *)
    fun new_leader all_nodes log = 
        let val nextIndex = get_log_index log
            val index = map (fn id => {peer = id, next = nextIndex + 1}) all_nodes
            val match_index = map (fn id => {peer = id, match = 0}) all_nodes
        in {
            nextIndex = index,
            matchIndex = match_index
        } end
    
    (* Get the nextIndex of a peer *)
    fun get_next_index leader_info peer = first (filter (fn (x) => x.peer = peer) leader_info.nextIndex)

    (* Get the matchIndex of a peer *)
    fun get_match_index leader_info peer = first (filter (fn (x) => x.peer = peer) leader_info.matchIndex)

    (* Updates a cluster member's next-index. This is done after an
    acknowledgement or rejection. *)
    fun update_next_index leader_info peer new = let
        val prevIndex = get_next_index leader_info peer
        val newIndex = {peer = peer, next = new}
        val withoutPeer = filter (fn (x) => x.peer <> peer) leader_info.nextIndex
    in {
        leader_info with 
        nextIndex = newIndex :: withoutPeer
    } end

    (* Updates a cluster member's match-index, denoting how much of their log
    matches the leader holding the leader info. *)
    fun update_match_index leader_info peer new = let
        val prevIndex = get_match_index leader_info peer
        val newIndex = {peer = peer, match = new}
        val withoutPeer = filter (fn (x) => x.peer <> peer) leader_info.matchIndex
    in {
        leader_info with 
        matchIndex = newIndex :: withoutPeer
    } end

    (* Get all follower's matchIndex*)
    fun get_matches leader_info = map (fn x => x.match) leader_info.matchIndex

    (* Get the highest index of entries that a majority of followers have
    appended to, by finding the median *)
    fun calc_highest_commit matches = median matches
    (* END OF libs/leader-info.trp *)

    (* Executes a function after a given timeout. *)
    fun start_timeout func duration = 
        let fun timeout () = 
            let val time = duration
                val _ = sleep time
            in func ()
            end
            val p_id = self()
        in spawn timeout
    end

    (* Send message after a delay. *)
    fun send_delay (to, m) delay =
        sleep delay;
        send (to, m)

    (* Starts a random timeout with lower=2sec and upper=4sec *)
    fun start_random_timeout func settings = start_timeout func (settings.ELECTION_TIMEOUT_LOWER + ((random ()) * (settings.ELECTION_TIMEOUT_UPPER - settings.ELECTION_TIMEOUT_LOWER)))

    (* #IMPORT ./libs/dialer.trp *)

(* Selects a random element from a list *)
fun random_element list =
    let fun roundUp n m = 
            if n <= 0 then m else roundUp (n - 1) (m + 1)
        val r_n = roundUp (random() * (length list - 1)) 0 
    in nth list r_n
end


(* Given a list of serialkeys, and a serial key, check if it is valid, and
return a list containing the serial key if so, and a boolean denoting whether or
not it is valid. *)
fun apply_serialkey list key =
    case list of
    [] => (true, [])
    | h :: t =>
        if h = key then
            case (h.key, key.key) of
            ((log_index, seq_numb), (new_log_index, new_seq_numb)) =>
                if new_log_index > log_index orelse 
                    (log_index = new_log_index andalso new_seq_numb > seq_numb) then
                    (true, ({ h with key = key.key } :: t))
                else (false, h :: t)
            | (nonce, new_nonce) =>
                if nonce <> new_nonce then
                    (true, ({ h with key = key.key } :: t))
                else (false, h :: t)
            | _ => (true, ({ h with key = key.key } :: t))
        else 
            let val (cond, list) = apply_serialkey t key
            in (cond, h :: list)
        end


(* Used by the dialer to send message to a cluster. If the nodes are busy or if
no leader is present, this function re-sends the message until it is eventually
delivered and acknowledged by the leader of the cluster. If leader is unknown,
it can be defined as unit.*)
fun dialer_send_message p_id msg serial_n leader cluster dialer_settings = 
    let val nonce = mkuuid()
        val msg_timeout = start_timeout (fn() => send(p_id, (DIALER_MESSAGE_TIMEOUT, nonce)))
        val busy_timeout = start_timeout (fn() => send(p_id, (DIALER_BUSY_TIMEOUT, nonce)))
        fun wait () =
            receive [
            hn ("NOT_LEADER", leader_id) => 
                dialer_send_message p_id msg serial_n leader_id cluster dialer_settings,
            hn ("DIALER_ACK", other_serial) when other_serial = serial_n => 
                leader,
            hn ("DIALER_SM_BUSY", other_serial) when other_serial = serial_n =>
                busy_timeout dialer_settings.DIALER_SM_BUSY_TIMEOUT;
                wait (),
            hn ("DIALER_SM_DONE", other_serial) when other_serial = serial_n =>
                leader,
            hn ("DIALER_MESSAGE_TIMEOUT", x) => 
                if x = nonce then dialer_send_message p_id msg serial_n (random_element cluster) cluster dialer_settings
                else wait (),
            hn ("DIALER_BUSY_TIMEOUT", x) => 
                if x = nonce then dialer_send_message p_id msg serial_n leader cluster dialer_settings
                else wait ()
        ]
        in (case leader of
            () => msg_timeout dialer_settings.DIALER_NOLEADER_TIMEOUT
            | x =>
                msg_timeout dialer_settings.DIALER_NOMSG_TIMEOUT; 
                send(x, msg));
            wait ()
end

(* Facilitates client-side interaction to the Raft cluster. Allows the
programmer to send messages to the cluster in the format (RAFT_UPDATE, msg)*)
fun dialer cluster client_id dialer_settings = 
    let val p_id = self()
        fun update_message x leader = let 
            val serial_n = mkuuid()
            in dialer_send_message p_id ((RAFT_UPDATE, x), p_id, serial_n) serial_n leader cluster dialer_settings
        end
        val leader = random_element cluster

        fun loop leader sks =     
            receive [
                hn ("RAFT_UPDATE", x) =>
                    loop (update_message x leader) sks,

                hn ("DIALER_CLIENT_MSG", msg, sk) =>
                    let val (cond, sks) = apply_serialkey sks sk
                    in 
                        (if cond then send(client_id, msg)
                        else ());
                        loop leader sks
                end,

                hn ("SEND_TO_NTH", n, x) =>
                    send_to_nth cluster x n;
                    loop leader sks,

                hn ("SEND_TO_ALL", x) => 
                    send_to_all cluster x (self());
                    loop leader sks,
                hn _ => loop leader sks ]
    in loop leader []
end

(* Temporary dialer sends a list of messages to a cluster before terminating. *)
fun leader_dialer cluster msgs dialer_settings = 
    let val p_id = self()
        val leader = random_element cluster
    in 
        map (fn (msg, serial) => dialer_send_message p_id ((RAFT_UPDATE, msg), p_id, serial) serial leader cluster dialer_settings) msgs
end

(* Send-function used for clusters to send a message to either the dialer or
client. *)
fun raft_send (process, msgs) dialer_settings = case process.type of
"CLIENT" => map (fn (msg, sk) => send(process.id, (DIALER_CLIENT_MSG, msg, sk))) msgs
| "CLUSTER" => spawn (fn () => leader_dialer process.id msgs dialer_settings)
(* END OF ./libs/dialer.trp *)

    (* Send the side-effect-messages to dialers or clusters *)
    fun send_sides log sides dialer_settings =
        (* Add message to key-value-store, sorting by the recipients. *)
        let fun add_msg id msg sk dict = case dict of
            [] => [(id, [(msg, sk)])]
            | (other_id, msgs) :: t =>
                if id = other_id then
                    (id, (msg, sk) :: t)
                else (other_id, msgs) :: add_msg id msg sk t
            (* Generate key-value-store of all message, sorting by recipients. *)
            val (sorted_msgs, _) = case sides of
            [] => ([], 0)
            | x => foldl (fn ((callback, msg), (acc, seq)) =>
                (add_msg callback msg ({ id = callback, key = (log.lastApplied, seq)}) acc, seq + 1)
            ) ([], 1) x
        (* Sends all messages. *)
        in map (fn x => raft_send x dialer_settings) sorted_msgs
    end

    (* Applies all log-entries that have been committed, but not applied *)
    fun apply_log log state_machine is_leader dialer_settings = 
        (* If any non-applied, committed logs apply... *)
        if log.lastApplied < log.commitIndex then
            (* Get the latest non-applied committed entry *)
            let val entry = get_nth_command log (log.lastApplied + 1) 
                val command = entry.command
                (* Update log to apply entry and apply entry on state-machine*)
                val log = update_applied log
                val (sides, status, step) = state_machine
                val (new_sides, new_status, new_step) = step command
            (* If leader is applying, execute side-effects. *)
            in (if is_leader then
                    entry.callback ();
                    send_sides log new_sides dialer_settings
                else ());
            apply_log log (new_sides, new_status, new_step) is_leader dialer_settings end
        else (log, state_machine)

    (* #IMPORT ./libs/nodes/leader.trp *)
fun leader_node node = 
    let val p_id = self()
        (* Appends appends all entries from a follower's nextIndex to the leader's log index*)
        fun append_entries node follower_pid =
                let val nextIndex = get_next_index node.leader_info follower_pid
                val logIndex = get_log_index node.log
            in if logIndex + 1 >= nextIndex.next then 
                let 
                    val latestLogIndex = nextIndex.next - 1
                in 
                    (* Sends the snapshot if the followers nextIndex is before the Snapshot's lastIncludedIndex *)
                    if nextIndex.next <= node.log.snapshot.lastIncludedIndex 
                        then send(follower_pid, (SNAPSHOT, node.log.snapshot, p_id, node.term))
                    else 
                        let val entries = get_commands_after_nth node.log.log latestLogIndex node.log.snapshot.lastIncludedIndex
                            val afterSnapshot = latestLogIndex - node.log.snapshot.lastIncludedIndex
                            val prevEntryTerm = 
                                if afterSnapshot > 0 then (get_nth_command node.log latestLogIndex).term 
                                else node.log.snapshot.lastIncludedTerm
                        in send(follower_pid, (APPEND_ENTRIES, entries, p_id, node.term, latestLogIndex, prevEntryTerm, node.log.commitIndex))
                    end
            end
            (* A follower should never get more entries than the leader *)
            else ()
        end

        (* Convert leader to follower *)
        fun demote term leader voted_for node = 
            {node with 
                term = term, 
                leader = leader,
                leader_info = (),
                voted_for = voted_for}

        fun append_update node msg callback serial = 
            let val latestLogIndex = get_log_index node.log
                val prevLogTerm = get_latest_log_term node.log
                val log = append_message node.log msg callback node.term serial
                val leader_info = update_match_index node.leader_info p_id (get_log_index log)
                val leader_info = update_next_index leader_info p_id ((get_log_index log) + 1)
                val node = {node with log = log, leader_info = leader_info}
            in node
        end

        (* Applies all committed log entries that have not already been applied *)
        fun apply_committed node = 
            let val prev_commit = node.log.commitIndex
                val highest_commit = calc_highest_commit (map (fn x => x.match) node.leader_info.matchIndex)
                val node = { node with log = update_commit node.log highest_commit }
                val (applied_log, new_sm) = apply_log node.log node.state_machine true node.settings.leader_dialer_settings
                val snapshot_log = 
                    if prev_commit < highest_commit then 
                        evaluate_snapshot_cond new_sm node.snapshot_cond applied_log
                    else 
                        applied_log
                val (_, status, _) = new_sm
                val node = { node with log = snapshot_log, state_machine = new_sm}
            in 
                case status of
                "SUS" => if log_is_committed node.log then append_update node () (fn () => ()) (mkuuid())
                    else node
                | _ => node
        end
            
        val nonce = mkuuid ()
        
        fun loop node =
            receive [
                (* Halts the leader *)
                hn "DEBUG_PAUSE" =>
                    let fun pause () = receive [
                        hn ("DEBUG_CONTINUE") => loop node,
                        hn x => pause ()
                    ]
                    in pause () end,

                hn ("SEND_HEARTBEAT", x) when nonce = x => 
                    leader_node node,

                (* Message has not been appended before *)
                hn (("RAFT_UPDATE", x), dialer_id, serial_n) => 
                    let val (cond, sks) = apply_serialkey node.serialkeys serial_n
                    in if cond then let
                        val (_, stat, _) = node.state_machine
                        val node = case stat of 
                            "SUS" => send(dialer_id, (DIALER_SM_BUSY, serial_n)); node
                            | "DONE" => send(dialer_id, (DIALER_SM_DONE, serial_n)); node
                            | "WAIT" => 
                                if log_is_committed node.log then
                                    let fun replication_cb () = send (dialer_id, (DIALER_ACK, serial_n))
                                    in append_update node x replication_cb serial_n end
                                else send(dialer_id, (DIALER_SM_BUSY, serial_n)); node
                        in leader_node node end
                    else send(dialer_id, (DIALER_ACK, serial_n));
                        loop node
                    end,

                (* If append is successful on a follower*)
                hn ("ACKNOWLEDGE", (peer, logIndex)) => 
                    let val prev_index = get_log_index node.log
                        val node = { node with leader_info = update_match_index node.leader_info peer logIndex }
                        val node = { node with leader_info = update_next_index node.leader_info peer (logIndex + 1) }
                        val node = apply_committed node
                        val next_index = get_next_index node.leader_info peer
                    in (if not node.settings.TIE_COMMITS_TO_HEARTBEAT andalso 
                        prev_index < get_log_index node.log then 
                            map (fn x => append_entries node x) 
                                (filter (fn x => 
                                    let val next_index = get_next_index node.leader_info x 
                                    in x <> p_id andalso next_index.next > logIndex end) node.all_nodes)
                        else ());
                        loop node
                    end,

                (* If append is unsuccessful *)
                hn ("REJECT", (peer, terminfo, logIndex)) => 
                    if node.term >= terminfo.term then 
                        let val node = { node with leader_info = update_next_index node.leader_info peer (logIndex + 1) } 
                        in loop node 
                        end
                    else follower (demote terminfo.term terminfo.leader ()
                    node),

                (* If another node has been elected as a candidate, and
                    their term is in front of ours, convert to a follower *)
                hn ("REQUEST_VOTE", (c_term, c_id, c_log_index, c_log_term)) when c_term > node.term =>
                    send(c_id, (YES_VOTE, node.id));
                    follower (demote c_term () c_id node),

                hn ("REQUEST_VOTE", (c_term, c_id, c_log_index, c_log_term)) =>
                    send(c_id, (NO_VOTE, node.id));
                    loop ({node with term = max c_term node.term}),

                (* If we receive snapshot from a leader in a higher term,
                convert to follower *)
                hn ("SNAPSHOT", snapshot, l_id, other_term) when other_term > node.term => follower (demote other_term l_id () node),
                
                (* If we receive AppendEntries from a leader in a higher term,
                convert to follower *)
                hn ("APPEND_ENTRIES", x, l_id, other_term, prevIndex, prevTerm, commitIndex) when other_term > node.term => follower (demote other_term l_id () node),
                
                (* Prints log *)
                hn "DEBUG_PRINTLOG" =>
                    pretty_print_log node.id node.log;
                    loop node,

                (* Applies a snapshot *)
                hn "DEBUG_APPLYSNAPSHOT" =>
                    let 
                        val snapshot = get_snapshot node.state_machine node.log
                        val node = case snapshot.snapshot of
                        () => node
                        | _ => {node with log = apply_snapshot snapshot node.log}
                    in loop node end,
                hn _ => loop node
            ]
    in 
        (* Append entries for each follower *)
        map (fn x => append_entries node x) (filter (fn x => x <> p_id) node.all_nodes);
        start_timeout (fn () => send (p_id, (SEND_HEARTBEAT, nonce))) node.settings.HEARTBEAT_INTERVAL;
        loop node
end
(* END OF ./libs/nodes/leader.trp *)
    (* #IMPORT ./libs/nodes/candidate.trp *)
and candidate node =
    let val p_id = self()

        (* A candidate cannot vote for anyone and has no leader *)
        val node = {node with voted_for = (), leader = ()}
        val nonce = mkuuid()

        (* Sends a vote request to all followers *)
        val latestLogIndex = get_log_index node.log
        val prevLogTerm = get_latest_log_term node.log
        

        (* Becoming a leader requires majority vote *)
        val req_votes = ((length node.all_nodes) / 2)
        
        fun won_election () = 
            let val (sides, _, _) = node.state_machine
            in
                send_sides node.log sides;
                leader_node ({ 
                    node with leader_info = (new_leader node.all_nodes node.log),
                    leader = (p_id)})
        end
        
        fun wait_for_votes (follower_votes, vote_amount) = 
            let 
                fun loop () = receive [
                (* Received a vote from a follower we have not already
                received a vote from *)
                hn ("YES_VOTE", follower_id) when (not (contains follower_id follower_votes)) => 
                    wait_for_votes ((append follower_votes [follower_id]), vote_amount + 1),

                (*We received a NO_VOTE from a follower in a later term.
                This can only happen if there is a leader/candidate in this
                term, and as such, we convert to a follower *)
                hn ("NO_VOTE", other_term) when other_term > node.term =>
                    follower node,

                (* Received vote request from candidate in later term *)
                hn ("REQUEST_VOTE", (c_term, other_c_id, c_log_index, c_log_term)) when c_term > node.term =>
                    send(other_c_id, (YES_VOTE, node.id));
                    follower ({ node with term = c_term, voted_for = other_c_id}),
                
                (* Received message from leader in a term at least as
                up-to-date as ours. Because of this, we must have lost the
                election *)
                hn ("APPEND_ENTRIES", x, l_id, other_term, prevIndex, prevTerm, commitIndex) when other_term >= node.term => 
                    follower ({ node with leader = l_id}),

                (* Election timeout, send out another request vote *)
                hn ("VOTE_TIMEOUT", x) when x = nonce => candidate {node with term = node.term + 1},

                (* Halts the candidate *)
                hn ("DEBUG_PAUSE") =>
                    let fun loop () = receive [
                        hn ("DEBUG_CONTINUE") => (),
                        hn x => loop ()
                    ]
                    in loop () end,
                hn _ => loop ()
            ]
            in if vote_amount >= req_votes then won_election () else loop ()
        end
    in 
        send_to_all node.all_nodes (REQUEST_VOTE, (node.term, p_id, latestLogIndex, prevLogTerm)) (p_id);
        start_random_timeout (fn () => send(p_id, (VOTE_TIMEOUT, nonce))) node.settings;
        wait_for_votes ([node.id], 1) 
end
(* END OF ./libs/nodes/candidate.trp *)
    (* #IMPORT ./libs/nodes/follower.trp *)
and follower node = 
    let val nonce = mkuuid()
        val p_id = self()
        val _ = start_random_timeout (fn () => send(p_id, (ELECTION_TIMEOUT, nonce))) node.settings
        (* Sends a YES_VOTE to a candidate *)
        fun vote_for c_id c_term node = 
            send(c_id, (YES_VOTE, node.id));
            { node with term = c_term, voted_for = c_id } 
        fun loop node = let
            fun start_election () =
                candidate ({node with term = node.term + 1})
            val _ = receive [
                (* Starts an election *)
                hn ("ELECTION_TIMEOUT", x) when x = nonce => start_election (),

                (* Sends a re-vote to a candidate we already voted for *)
                hn ("REQUEST_VOTE", (c_term, c_id, c_log_index, c_log_term)) when c_id = node.voted_for =>
                    follower (vote_for c_id c_term node),
                
                (* If we receive a vote request, vote yes if: the log is a
                up-to-date and the term of the candidate is later than our
                current. Vote no otherwise *)
                hn ("REQUEST_VOTE", (c_term, c_id, c_log_index, c_log_term)) =>
                    let val latestLogIndex = get_log_index node.log
                        val latestLogTerm = get_latest_log_term node.log
                        val old_term = node.term
                        val node = {node with term = max c_term old_term}
                        fun no_vote () =
                            send(c_id, NO_VOTE);
                            follower node
                        fun yes_vote () =
                            follower (vote_for c_id c_term ({node with term = c_term}))
                    in 
                        if latestLogIndex > c_log_index
                        orelse latestLogTerm <> c_log_term
                        orelse node.term = old_term then no_vote ()
                        else yes_vote ()
                    end,

                (* When receiving a snapshot from a leader in a later or
                same term, acknowledge if it contains entries past our
                current log index. Update leader and term accordingly. *) 
                hn ("SNAPSHOT", x, l_id, leader_term) => 
                    let val node = {node with leader = 
                            if node.leader = () orelse node.term < leader_term then l_id 
                            else node.leader} 

                        val {snapshot, lastIncludedIndex, lastIncludedTerm} = x 
                        val log_term = get_latest_log_term node.log 
                        val log_index = get_log_index node.log

                        val accepting = 
                            if leader_term < node.term then false
                            else if lastIncludedIndex <= log_index then false
                            else true

                        val newlog = if accepting then apply_snapshot x node.log else node.log
                        val new_sm = if accepting then snapshot else node.state_machine
                        val reject = 
                            fn () => send (l_id, (REJECT, (p_id, {term = node.term, leader = node.leader}, (get_log_index newlog))))
                        val ack = 
                            fn () => send (l_id, (ACKNOWLEDGE, (p_id, get_log_index newlog)))

                        val node = {
                            node with term = (if node.term < leader_term then leader_term else node.term), 
                            state_machine = new_sm, 
                            log = newlog}
                    in (if accepting then ack ()
                                else reject ());
                        follower node
                    end,

                (* When receiving entries from a leader in a later or
                same term, acknowledge if it contains entries past our
                current log index. And if the latest log index matches ours.
                Update log accordingly.*)
                hn ("APPEND_ENTRIES", x, l_id, leader_term, latestLogIndex, prevLogTerm, leaderCommit) => 
                    let val node = {node with leader = 
                            if node.leader = () orelse node.term <= leader_term then l_id
                            else node.leader}
                        val accepting = 
                            if leader_term < node.term then false
                            else if latestLogIndex > (get_log_index node.log) then false
                            else if (get_latest_log_term node.log) <> prevLogTerm andalso prevLogTerm > 0 then false
                            else true
                        val prev_commit = node.log.commitIndex
                        val newlog = 
                            if accepting then
                                let val log = rollback_log_to node.log latestLogIndex
                                    val log = add_entries_to_log log x leader_term
                                in update_commit log (min leaderCommit (get_log_index log)) 
                                end
                            else node.log
                        val reject = 
                            fn () => send (l_id, (REJECT, (p_id, {term = node.term, leader = node.leader}, (get_log_index newlog))))
                        val ack = 
                            fn () => send (l_id, (ACKNOWLEDGE, (p_id, get_log_index newlog)))

                        val node = {node with term = (if node.term < leader_term then leader_term else node.term)}
                        val (applied_log, new_sm) = apply_log newlog node.state_machine false node.settings.leader_dialer_settings
                        val snapshot_log =
                            if prev_commit < applied_log.commitIndex then 
                                evaluate_snapshot_cond new_sm node.snapshot_cond applied_log
                            else 
                                applied_log
                    in 
                        (if accepting then ack ()
                        else reject ());
                        follower {node with log = snapshot_log, state_machine = new_sm}
                    end,

                (* If client sends update, sends the leader's id *)
                hn (("RAFT_UPDATE", x), dialer_id, _) => 
                    send(dialer_id, (NOT_LEADER, node.leader));
                    loop node,

                (* Prints the log *)
                hn ("DEBUG_PRINTLOG") =>
                    pretty_print_log node.id node.log;
                    loop node,

                (* Halts the follower *)
                hn ("DEBUG_PAUSE") =>
                    let fun paused () = receive [
                        hn ("DEBUG_CONTINUE") => (),
                        hn _ => paused ()
                    ]
                    in
                        paused ();
                        loop node
                    end,

                (* Start an election, electing this follower to a candidate *)
                hn ("DEBUG_TIMEOUT") => start_election (),
                hn _ => loop node
        ]
        in ()
    end
    in loop node
end
(* END OF ./libs/nodes/follower.trp *)

    (* A node is dormant until it has received the references of all other <nodes. *)
    fun dormant_node node =
        if length(node.all_nodes) < node.node_amount then
            receive [
                (* Adds a node to the cluster, only used for initialization *)
                hn ("ADD_NODES", x) => 
                    dormant_node ({node with all_nodes = append node.all_nodes x})
            ]
        else follower node
    
    (* Defines a default node, being a follower in term 1 without a leader and
    the state-machine in its beginning state *)
    fun default_node id all_nodes node_amount state_machine settings = 
        let val node = {
            all_nodes = all_nodes,
            id = id,
            log = empty_log,
            term = 1,
            voted_for = (),
            leader = (),
            leader_info = (),
            state_machine = case state_machine of
                (_, _, _) => state_machine
                | _ => ([], WAIT, fn x => x ()),
            snapshot_cond = settings.MAXIMUM_LOG_SIZE,
            node_amount = node_amount,
            serialkeys = [],
            settings = settings
        }
        in dormant_node node
    end

    (* Spawn a state-machine on a seperate thread, creates a record*)
    fun initiate_node state_machine node_amount id settings = 
        spawn (fn () => default_node id [] node_amount state_machine settings)

    (* Sends a list of all nodes to all nodes *)
    fun add_refs nodes = 
        map (fn x => send(x, (ADD_NODES, nodes))) nodes
    
    (* Spawn n nodes*)
    fun initiate_nodes n state_machine settings =
        let val part_init = initiate_node state_machine n
            fun spawn_nodes n acc_id =
                case n of
                0 => []
                | x => append 
                    (spawn_nodes (x - 1) (acc_id ^ "I")) 
                    [(part_init acc_id settings)]

            val nodes = spawn_nodes n "I"
        in 
            add_refs nodes;
            nodes
    end

    (* Spawn a state-machine on some alias *)
    fun initiate_distributed_node state_machine node_amount id alias settings = 
        spawn(alias, fn () => (default_node id [] node_amount state_machine settings))

    fun initiate_distributed_nodes aliases state_machine settings =
        let val part_init = initiate_distributed_node state_machine (length(aliases))
            fun spawn_nodes acc acc_id =
                case acc of 
                [] => []
                | h :: t =>
                    append (spawn_nodes t (acc_id ^ "I")) [part_init acc_id h settings]
            val nodes = spawn_nodes aliases "I"
        in 
            add_refs nodes;
            nodes
    end

    val default_dialer_settings = {
        DIALER_NOLEADER_TIMEOUT = 500,
        DIALER_NOMSG_TIMEOUT = 2000,
        DIALER_SM_BUSY_TIMEOUT = 1000
    }

    val default_local_settings = {
        ELECTION_TIMEOUT_LOWER = 2000,
        ELECTION_TIMEOUT_UPPER = 4000,
        HEARTBEAT_INTERVAL = 500,
        TIE_COMMITS_TO_HEARTBEAT = true,
        MAXIMUM_LOG_SIZE = 50,
        leader_dialer_settings = default_dialer_settings
    }

    val default_distributed_settings = {
        ELECTION_TIMEOUT_LOWER = default_local_settings.ELECTION_TIMEOUT_LOWER,
        ELECTION_TIMEOUT_UPPER = default_local_settings.ELECTION_TIMEOUT_UPPER,
        HEARTBEAT_INTERVAL = default_local_settings.HEARTBEAT_INTERVAL,
        MAXIMUM_LOG_SIZE = default_local_settings.MAXIMUM_LOG_SIZE,
        TIE_COMMITS_TO_HEARTBEAT = false,
        leader_dialer_settings = default_local_settings.leader_dialer_settings
    }


    (* Spawns a dialer, dialing into a cluster. *)
    fun raft_dial (cluster, client_id, dialer_settings) =
        spawn(fn () => dialer cluster client_id dialer_settings)
    | raft_dial (cluster, client_id) = raft_dial (cluster, client_id, default_dialer_settings)

    (* Spawns a distributed Raft network, which can be dialed into to
    communicate with their state-machines *)
    fun raft_spawn_alias (state_machine, aliases, settings) = 
        initiate_distributed_nodes aliases state_machine settings
    | raft_spawn_alias (state_machine, aliases) = 
        raft_spawn_alias (state_machine, aliases, default_distributed_settings)

    (* Spawns a Raft network, which can be contacted to
    communicate with their state-machines *)
    fun raft_spawn (state_machine, n, settings) =
        initiate_nodes n state_machine settings
    | raft_spawn (state_machine, n) = raft_spawn (state_machine, n, default_local_settings)

in [("raft_spawn_alias", raft_spawn_alias),
    ("raft_spawn", raft_spawn),
    ("raft_dial", raft_dial),
    ("default_dialer_settings", default_dialer_settings),
    ("default_distributed_settings", default_distributed_settings),
    ("default_local_settings", default_local_settings),
    ("WAIT", WAIT),
    ("SUS", SUS),
    ("DONE", DONE),
    ("CLIENT", CLIENT),
    ("CLUSTER", CLUSTER),
    ("RAFT_UPDATE", RAFT_UPDATE)
    ]
end
