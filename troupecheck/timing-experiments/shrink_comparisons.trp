import troupecheck
import lists
(* NOTE: for this program to work, troupecheck library file needs to modified to return a tuple on the form: 
        (<<bool>>, <<counterexample sequence>>, <<size at which test failed>>, <<counterexample>>)
    when a failing a test. 
    The test that is run must always fail at some point. 
    This program was only made to test internal vs. external shrinking, and not meant for further usage.*)
let fun record_shrink_test r = 
        r.theInteger < 50
    fun prop_record_shrink() = for_all ([(record (["theInteger", "theString"], [integer(), string()]))], record_shrink_test)

(* 
------------------------------
INTERNAL SHRINKING

------------------------------
*)
    fun report_error tup = 
        print tup.0;
        exit (authority, 0)

    fun boolean_check x tco = 
        ()

    fun function_not_done_check p tco = 
        ()
(*
--------------------------------
UTILS

Different utility functions that are used across the library.

-------------------------------- 
*)  
    fun remove_nth n [] i = []
    | remove_nth n (x::xs) i = 
        if n = i then xs
        else x :: (remove_nth n xs (i + 1))

    fun make_list (f, i) = 
        case i of 
        0 => []
        | _ => append [f()] (make_list (f, i-1))
    

(* TODO: handle when arguments are passed to a property that does not take arguments *)
    fun apply_args p l tco =
        let val _ = send (tco, ("REQUEST_AUTH", self()))
            val auth = receive [hn x => x]
        in case l of 
            [] =>  (* this case is only reached if there are no generators to begin with *)
                let val _ = boolean_check (p()) tco
                    val res = p() 
                    val _ = blockdecl auth 
                in declassify (res, auth, `{}`) 
                end
            | (x::xs) => 
                let val res = foldl (fn (x,y) => function_not_done_check y tco; y x) p l
                    val _ = boolean_check res tco
                    val _ = blockdecl auth
                in declassify (res, auth, `{}`)
            end
        end
    
    fun string_to_list s = 
        let fun aux "" acc = acc 
            | aux s acc = 
                let val x = substring (s, 0, 1)
                    val xs = substring (s, 1, 1/0) in 
                aux xs (append acc [x]) end in 
        aux s [] end
    
    (* Combines a list of individual strings to a single string *)
    fun list_to_string ls tco = 
        foldl (fn (x,y) => if getType x <> "string" then report_error ("non_string_type", 0) tco else y ^ x) "" ls
    
    fun string_length s = 
        length (string_to_list s)

    fun build_record names vals = 
        let fun aux r [] [] = r 
            | aux r (n::ns) (v::vs) = 
                aux (recordExtend(r, n, v)) ns vs in
        aux {} names vals 
        end
    
    (* Hardcoded until a tuple from list function is implemented in Troupe - an issue has been raised on GH.*)
    fun build_tuple ls = 
                case ls of 
                [] => (0)
                |[x] => (x) 
                |[x1,x2] => (x1,x2)
                |[x1,x2,x3] => (x1,x2,x3)
                |[x1,x2,x3,x4] => (x1,x2,x3,x4)
                |[x1,x2,x3,x4,x5] => (x1,x2,x3,x4,x5)
                |[x1,x2,x3,x4,x5,x6] => (x1,x2,x3,x4,x5,x6)
                |[x1,x2,x3,x4,x5,x6,x7] => (x1,x2,x3,x4,x5,x6,x7)
                |[x1,x2,x3,x4,x5,x6,x7,x8] => (x1,x2,x3,x4,x5,x6,x7,x8)
                |[x1,x2,x3,x4,x5,x6,x7,x8,x9] => (x1,x2,x3,x4,x5,x6,x7,x8,x9)
                |[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10] => (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)
                |_ => (2, 3, 4, 5) 
    
        fun dec_nth list idx = 
            let fun dec_nth_aux [] acc i = acc 
                | dec_nth_aux (x::xs) acc i =
                    case i = idx of 
                    true =>
                        let val dec_val = if x <= 1/10000 then 0 else x/(3/2) in
                        append (append acc [dec_val]) xs end
                    | false => dec_nth_aux xs (append acc [x]) (i+1)
        in  
            dec_nth_aux list [] 0 end
        
    fun zero_nth list idx = 
            let fun zero_nth_aux [] acc i = acc 
                | zero_nth_aux (x::xs) acc i =
                    case i = idx of 
                    true =>
                        append (append acc [0]) xs
                    | false => zero_nth_aux xs (append acc [x]) (i+1)
        in  
            zero_nth_aux list [] 0 end
    
    fun dec_all seq = 
        let fun dec_all_aux [] i = [] 
            | dec_all_aux (x::xs) i = 
                if x = 0 then
                    dec_all_aux xs (i+1)
                else 
                    [(fn () =>  (zero_nth seq i)), (fn() => [fn () =>  (dec_nth seq i), fn () => dec_all_aux xs (i+1)])] in 
        dec_all_aux seq 0 end
    
    fun seqs_of_seq sequence lengths = 
        let fun aux seq acc 0 = (acc, seq) 
            | aux (x::xs) acc n = 
                aux xs (append acc [x]) (n-1) 
            val (res, _) = (foldl (fn (x,(acc, s)) => 
                                let val (curr_acc, curr_seq) = aux s [] x in 
                                (append acc [curr_acc], curr_seq) end)([], sequence) lengths)
        in res 
        end

    fun cutoff_at list idx = 
        let fun aux ls acc 0 = acc
            | aux (x::xs) acc i = 
                aux xs (append acc [x]) (i-1) in 
        aux list [] idx end 
    
    fun for_i f y 0 = y
      | for_i f y i = for_i f (f (i,y)) (i-1)
(* 
--------------------------------
SHRINKING

Works by first using random shrinking when a failing example has been found (shrink & random_shrink_aux). 
Random shrinking means simply generating new test cases with gradually smaller size, to find a case smaller than the original one. This rarely produces a minmal result.
The smallest randomly shrunk instance is then further shrunk using internal shrinking. (internal_shrink & internal_shrink_aux)
Internal shrinking means keeping track of all random decision made during generation, and then re-generating with smaller "random" decisions.

This part of the code also contains the functionality for recording all random decisions, and replaying these random decisions (rec_rng & rep_rng).
All of these functions are spawned and then requests or updates may be send to them, so that the correct RNG's are used at different points in the code.

-------------------------------- 
*)  
    fun init_tc auth rng =  
        receive [hn ("REQUEST_RNG", senderid) => 
                    let val _ = send (senderid, rng) 
                    in init_tc auth rng end,

                hn ("REQUEST_AUTH", senderid) => 
                    let val _ = send (senderid, auth) 
                    in init_tc auth rng end,

                hn ("UPDATE_RNG", senderid, new_rng) => 
                    let val _ = send(senderid, "done") in
                    init_tc auth new_rng end]
    

    fun rec_rng ls =
        receive [hn ("REQUEST_RND", senderid) =>
                    let val rnd = random()
                        val _ = send (senderid, rnd) 
                        in rec_rng (rnd :: ls)
                        end, 
                hn ("REQUEST_SEQ", senderid) => 
                    let val _ = send (senderid, (reverse ls))
                    in rec_rng []
                    end]
    
    fun rep_rng ls = 
        receive [hn ("REQUEST_RND", senderid) => 
                    case ls of 
                    (x::xs) => 
                        let val _ = send (senderid, x) 
                        in rep_rng xs
                        end 
                    | [] => 
                        let val _ = send (senderid, 0)
                        in rep_rng ls 
                        end, 
                hn ("REQUEST_LEFT", senderid) => 
                    let val _ = send (senderid, ls)
                    in rep_rng [] 
                    end, 
                hn ("UPDATE_LS", new_ls) => 
                    rep_rng new_ls]
    
    fun shrink_sized_sequence seqs gens prop pre size left_over_len idx_of_sized tco = 
        let val _ = send(tco, ("REQUEST_RNG", self())) 
            val pid = receive [hn x => x]
            val _ = send(tco, ("REQUEST_AUTH", self())) 
            val auth = receive [hn x => x]
            val cap = ceil (((length (nth seqs (idx_of_sized+1)))-2)/left_over_len )(* number of to remove parts of the sequence *)
            val size_ls = for_i (fn (x,y) => append y [x]) [] (left_over_len-1)
            fun aux i = 
                let val to_remove = foldl (fn (x,y) => append y [(i*left_over_len)-x])[i*left_over_len] size_ls
                        val new_seq = foldl (fn (x,y) => remove_nth x y 0) (nth seqs (idx_of_sized+1)) to_remove
                        val new_seqs = mapi (fn (i, x) => if i = idx_of_sized then new_seq else x) seqs
                        val new_args = mapi (fn (i, x) =>
                                        let val _ = send (pid, ("UPDATE_LS", (nth new_seqs (i+1))))
                                            val arg = x tco size
                                        in arg
                                        end) gens
                in case i = (cap) of 
                true => 
                    (new_seqs, new_args)
                | false => 
                    let val precond_is_met = if (pre <> ()) then (apply_args pre new_args tco) else true 
                    in case (apply_args prop new_args tco) orelse (precond_is_met = false) of 
                        true => aux (i+1)
                        | false => (new_seqs, new_args) 
                    end 
                end 
        in aux 1
        end



    fun internal_shrink_aux seqs gens lengths prop pre size counter tco = 
        let val _ = send(tco, ("REQUEST_RNG", self())) 
            val pid = receive [hn x => x]
            val _ = send(tco, ("REQUEST_AUTH", self())) 
            val auth = receive [hn x => x]
        in case seqs of 
        (x1::x2::x3::xs) => 
            let val seqs_of_curr = seqs_of_seq (x2()) lengths
                val args_and_leftovers = mapi (fn (i, x) =>
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = x tco size
                                            val _ = send (pid, ("REQUEST_LEFT", self()))
                                            val left_overs = receive [hn x => x] 
                                        in {arg = arg, left_overs = left_overs}
                                        end) gens
                val (test_args, left_over_seqs) = foldl (fn (x, (raws, left_overs)) => (append raws [x.arg], append left_overs [x.left_overs])) ([],[]) args_and_leftovers
                (* val ret_seqs = mapi (fn (i,x) => 
                                        if (length x) = 0 then (nth seqs_of_curr (i+1)) 
                                        else cutoff_at (nth seqs_of_curr (i+1)) ((nth lengths (i+1))-(length x))) left_over_seqs *)
                val (is_sized_sequence, idx_of_sized, left_over_size, _) = foldl (fn (x,(bool, idx, len, count)) => if (length x > 0) 
                                                                            then (true, count, (length x), (count+1))
                                                                            else (bool, idx, len, (count+1))) (false, -1, 0, 0) left_over_seqs
                
                val (ret_seqs, args) = if is_sized_sequence 
                                then shrink_sized_sequence seqs_of_curr gens prop pre size left_over_size idx_of_sized tco
                                else (seqs_of_curr, test_args)
                val precond_is_met = if (pre <> ()) then (apply_args pre args tco) else true 
            in    
                case (apply_args prop args tco) orelse (precond_is_met = false) of 
                    true => internal_shrink_aux (x1::x3()) gens lengths prop pre size counter tco
                    | false => internal_shrink ret_seqs gens prop pre size (counter+1) tco 
            end 
        | (x::xs) => 
            let val seqs_of_curr = seqs_of_seq (x()) lengths
                val test_args = mapi (fn (i, y) => 
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = y tco size 
                                            in arg end) gens
                val precond_is_met = if (pre <> ()) then (apply_args pre test_args tco) else true
            in  
                case (apply_args prop test_args tco) orelse (precond_is_met = false) orelse (size < 0) of 
                    true => 
                        let val res = mapi (fn (i, y) => 
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = y tco (size+1) 
                                            in arg end) gens in 
                        {shrunk_ctx = res, count = counter} end
                    | false => internal_shrink_aux [x] gens lengths prop pre (size-1) counter tco
                
            end 
        end

    and internal_shrink sequences gens prop pre size counter tco = 
        let val (seqs_comb, seq_lengths) = foldl (fn (x, (seq, lengths)) => ((append seq x), (append lengths [(length x)]))) ([], []) sequences
        in
            if foldl (fn (x,y) => (x = 0) andalso y) true seqs_comb then 
                internal_shrink_aux [fn () => seqs_comb] gens seq_lengths prop pre size counter tco
            else  
                let val decreased_seqs = dec_all seqs_comb
                    val dec_seqs_w_root = append [fn() => seqs_comb] decreased_seqs
                    val res = internal_shrink_aux dec_seqs_w_root gens seq_lengths prop pre size (counter) tco
                in 
                res end
        end
    
    fun random_shrink_aux sequences generators prop pre success size counter divi tco =
        if (counter = 100) orelse (size = 0) then {count = success, size = size, sequences = sequences} else
        let val _ = send(tco, ("REQUEST_RNG", self()))
            val pid = receive [hn x => x]
            val new_size = floor (size/divi)
            val (shrunk_args, shrunk_sequences) = 
                                        foldl (fn (x, (arg_acc, seq_acc)) => 
                                                let val arg = x tco new_size
                                                    val _ = send (pid, ("REQUEST_SEQ", self()))
                                                    val seq = receive [hn x => x]
                                                in (append arg_acc [arg], append seq_acc [seq]) 
                                                end) ([],[]) generators
            val precond_is_met = if (pre <> ()) then (apply_args pre shrunk_args tco) else true 
        in
            case (apply_args prop shrunk_args tco) orelse (precond_is_met = false) of
                true => random_shrink_aux sequences generators prop pre success size (counter+1) (divi+2) tco
                | false =>
                    random_shrink_aux shrunk_sequences generators prop pre (success+1) new_size (0) 2 tco
        end

    fun internal_shrinker sequence generators prop pre size counter tco = 
        let val start_time = getTime()
            val rng_recorder = spawn (fn() => rec_rng [])
            val _ = send (tco, ("UPDATE_RNG", self(), rng_recorder))
            val _ = receive [hn x => ()]
            val res = random_shrink_aux sequence generators prop pre 0 size counter 2 tco
            val rng_replayer = spawn (fn() => rep_rng [])
            val _ = send (tco, ("UPDATE_RNG", self(), rng_replayer))
            val _ = receive [hn x => ()]
            val res = internal_shrink (res.sequences) generators prop pre res.size (res.count) tco
            val end_time = getTime()
        in 
            (res, (end_time-start_time))
        end 

(* 
------------------------------
EXTERNAL SHRINKING

------------------------------
*)
    fun abs_value x = 
    if x < 0 then -x else x 

    fun list_to_string ls = 
        foldl (fn (x,y) => if getType x <> "string" then report_error ("non_string_type", 0) else y ^ x) "" ls

    fun apply_args p l =
        case l of 
            [] => boolean_check (p()); p() (* this case is only reached if there are no generators to beign with*)
            | (x::xs) => 
                let val res = foldl (fn (x,y) => function_not_done_check y; y x) p l in
                boolean_check res;
                res 
                end
    
    fun shrink_sized_aggregate vals builder rec =
            case rec.state of 
            "init" => 
                let val init_shrink_idx = 0
                    val new_vals = mapi (fn (i, x) => 
                                            if i = init_shrink_idx then (x.shrinker {state = "init", curr = x.raw, prev = x.raw}) 
                                            else {state = "init", curr = x.raw, prev = x.raw}) vals
                    val new_raw_vals = map (fn x => x.curr) new_vals
                    val new_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true new_vals) then "done" else "cont"
                    val shrink_idx = if (nth new_vals (init_shrink_idx+1)).state = "done" then init_shrink_idx+1 else init_shrink_idx
                in 
                    {state = new_state, curr = (builder new_raw_vals), prev = rec.curr, next_shrink_info = new_vals, shrink_idx = shrink_idx}
                end
            | "cont" =>
                let val init_shrink_idx = rec.shrink_idx
                    val new_vals = mapi (fn (i, x) => 
                                            if i = init_shrink_idx then x.shrinker (nth rec.next_shrink_info (i+1)) 
                                            else (nth rec.next_shrink_info (i+1))) vals
                    val new_raw_vals = map (fn x => x.curr) new_vals
                    val new_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true new_vals) then "done" else "cont"
                    val shrink_idx = if (nth new_vals (init_shrink_idx+1)).state = "done" then init_shrink_idx+1 else init_shrink_idx
                in 
                    {state = new_state, curr = (builder new_raw_vals), prev = rec.curr, next_shrink_info = new_vals, shrink_idx = shrink_idx}
                end
            | "done" => 
                rec 
            | "rollback" =>
                let val init_shrink_idx = rec.shrink_idx
                    fun rollback_aux (i, x) = 
                        if i = init_shrink_idx then
                            (let val val_to_shrink = {(nth rec.next_shrink_info (i+1)) with state = "rollback"}
                            in 
                                x.shrinker val_to_shrink 
                            end )
                            else (nth rec.next_shrink_info (i+1)) 
                    val rollback_args = mapi rollback_aux vals
                    val new_raw_vals = map (fn x => x.curr) rollback_args
                    val new_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true rollback_args) then "done" else "cont"
                    val shrink_idx = if (nth rollback_args (init_shrink_idx+1)).state = "done" then init_shrink_idx+1 else init_shrink_idx
                in 
                    {state = new_state, curr = (builder new_raw_vals), prev = rec.curr, next_shrink_info = rollback_args, shrink_idx = shrink_idx}
                end
        
    fun shrink_float rec = 
        let val rec_checked = if rec.curr = 0 then {rec with state = "done"} else rec 
            val curr_val = rec_checked.curr 
        in 
        case rec_checked.state of 
        "rollback" => 
            {state = "done", curr = rec_checked.prev, prev = rec_checked.curr}
        |"done" => 
            rec_checked
        | _ => 
            let val new_raw_val = if (abs_value curr_val)-1 <= 0 then 0 else curr_val-1 
            in 
            {state = "cont", curr = new_raw_val, prev = rec_checked.curr} 
            end 
        end
    
    fun shrink_int rec = 
        let val interim = shrink_float rec 
        in 
        {interim with curr = floor(interim.curr)} 
        end
    
    fun remove_nth n [] i = []
    | remove_nth n (x::xs) i = 
        if n = i then xs
        else x :: (remove_nth n xs (i + 1))
    
    fun shrink_list shrinkers rec  = 
        if (rec.curr = []) andalso (rec.state <> "rollback") then {rec with state = "done", prev = rec.curr, idx = 0}
        else 
            case rec.state of 
            "init" => 
                let val removeIdx = (length (rec.curr)) - 1
                    val newList = remove_nth removeIdx rec.curr 0 
                    val new_shrinkers = remove_nth removeIdx shrinkers 0 
                    val next_state = if length newList = 0 then "cont_elem" else "cont_size"
                in 
                    {state = next_state, curr = newList, prev = rec.curr, idx = removeIdx, shrinkers = new_shrinkers, prev_shrinkers = shrinkers} 
                end
            | "cont_size" => 
                let val remove_idx = (rec.idx - 1)
                    val next_state = if remove_idx <= 0 then "cont_elem" else "cont_size"
                    val new_list = remove_nth remove_idx rec.curr 0 
                    val new_shrinkers = remove_nth remove_idx rec.shrinkers 0 
                in  
                    {state = next_state, curr = new_list, prev = rec.curr, idx = remove_idx, shrinkers = new_shrinkers, prev_shrinkers = rec.shrinkers} 
                end
            | "cont_elem" => 
                let val interim_list = mapi (fn (i, x) => (nth rec.shrinkers (i+1)){state = "init", curr = x, prev = x}) rec.curr
                    val next_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true interim_list) then "done" else "cont_elem"
                    val new_list = map (fn x => x.curr) interim_list 
                in
                    {state = next_state, curr = new_list, prev = rec.curr, idx = rec.idx, shrinkers = rec.shrinkers, prev_shrinkers = rec.prev_shrinkers} 
                end
            | "rollback" => 
                if (length rec.curr) = (length rec.prev) then 
                    {state = "done", curr = rec.prev, prev = rec.curr, idx = rec.idx, shrinkers = rec.prev_shrinkers, prev_shrinkers = rec.shrinkers} (* TODO: this loops an unecesary amount of times *)
                else 
                    {state = "cont_size", curr = rec.prev, prev = rec.curr, idx = rec.idx, shrinkers = rec.prev_shrinkers, prev_shrinkers = rec.shrinkers}
            | "done" => 
                rec

    fun shrink_char rec = 
        let val chars = 
            ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
            "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
            val rec_checked = if rec.curr = "a" then {rec with state = "done"} else rec 
            val curr_val = rec_checked.curr in
        case rec_checked.state of 
        "rollback" =>
            {state = "done", curr = rec.prev, prev = rec.curr, idx = rec.idx}
        | "done" =>
            rec_checked
        | "init" => 
            let val index_of_new = (lookup chars rec.curr 2) - 1
                val new_char = nth chars index_of_new 
            in 
                {state = "cont", curr = new_char, prev = rec.curr, idx = index_of_new}
            end
        | _ =>
            let val index_of_new = rec.idx-1
                val new_char = nth chars index_of_new 
            in 
                {state = "cont", curr = new_char, prev = rec.curr, idx = index_of_new}
            end
        end

    fun shrink_string rec = 
        let val rec_checked = if rec.state = "init" then {rec with next_shrink_info = 0} else rec in
        case rec_checked.state of 
        "cont_elem" => 
            {rec_checked with state = "done"} (* TODO: Should actually shrink characters *)
        | _ =>
            let val ls_curr = string_to_list rec_checked.curr
                val ls_prev = string_to_list rec_checked.prev
                val shrinkers = map (fn _ => shrink_char) ls_curr   
                val interim_res = 
                    shrink_list shrinkers {state = rec_checked.state, 
                                           curr = ls_curr, 
                                           prev = ls_prev, 
                                           idx = rec_checked.next_shrink_info, 
                                           shrinkers = shrinkers,
                                           prev_shrinkers = shrinkers} 
                val new_curr = list_to_string interim_res.curr
                val new_prev = list_to_string interim_res.prev

                val res = {state = interim_res.state, curr = new_curr, prev = new_prev, next_shrink_info = interim_res.idx} 
            in
                res 
            end
        end

    fun args_shrink args = 
        case args.state of 
        "rollback" => 
            let val init_shrink_idx = args.shrink_idx
                val rollbackReadyArgs = mapi (fn (i, x) => if (x.state = "done") orelse (i<>init_shrink_idx) then x else {x with state = "rollback"}) args.args
                val argsRolledBack = mapi (fn (i, x) => if i = init_shrink_idx then (nth args.shrinkers (i+1)) x else x) rollbackReadyArgs 
                val nextState = if (foldl (fn (x,y) => (x.state = "done") andalso y) true argsRolledBack) then "done" else "cont" 
                val shrink_idx = if (nth argsRolledBack (init_shrink_idx+1)).state = "done" then init_shrink_idx+1 else init_shrink_idx
            in
                {state = nextState, args = argsRolledBack, shrinkers = args.shrinkers, shrink_idx = shrink_idx} 
            end
        | "done" => 
            args
        | _ => 
            let val init_shrink_idx = args.shrink_idx
                val newArgs = mapi (fn (i, x) => if i = init_shrink_idx then ((nth args.shrinkers (i+1)) x) else x) args.args
                val nextState = if (foldl (fn (x,y) => (x.state = "done") andalso y) true newArgs) then "done" else "cont" 
                val shrink_idx = if (nth newArgs (init_shrink_idx+1)).state = "done" then init_shrink_idx+1 else init_shrink_idx

            in 
                {state = nextState, args = newArgs, shrinkers = args.shrinkers, shrink_idx = shrink_idx} 
            end

    fun shrink_aux args prop pre counter = 
        if counter = 100 then report_error ("shrinking_looped", 0) else
        let val shrunk_args = args_shrink args 
            val shrunk_args_raw = map (fn x => x.curr) shrunk_args.args 
            val precond_is_met = if (pre <> ()) then (apply_args pre shrunk_args_raw) else true 
            
        in case (apply_args prop shrunk_args_raw) orelse (precond_is_met = false) of
            true => shrink_aux (args_shrink {state = "rollback", args = shrunk_args.args, shrinkers = args.shrinkers, shrink_idx = args.shrink_idx}) prop pre (counter)
            | false =>
                if shrunk_args.state = "done" then {shrunk_ctx = shrunk_args_raw, count = counter} else shrink_aux shrunk_args prop pre (counter+1) end

    fun external_shrinker args prop pre = 
        let val start_time = getTime()
            val shrinkers = map (fn x => x.shrinker) args 
            val args_shrink_ready = map (fn x => {state = "init", curr = x.raw, prev = x.raw}) args
            val args_rec = {state = "init", args = args_shrink_ready, shrinkers = shrinkers, shrink_idx = 0}
            val res = shrink_aux args_rec prop pre 0 
            val end_time = getTime()
        in (res, (end_time - start_time)) end

    

    fun test_shrinking n = 
        let fun aux acc 0 = acc 
            | aux acc i = 
                let val (_, ctx_seq, size, ctx) = troupecheck [prop_record_shrink] authority 
                    val ctx_n = nth ctx 1
                    val ts_vals = [{raw = ctx_n.theInteger, shrinker = shrink_int}, {raw = ctx_n.theString, shrinker = shrink_string} ]
                    val ext_shrink_val = [{raw = ctx_n, shrinker = shrink_sized_aggregate ts_vals (build_record ["theInteger", "theString"])}]
                    val inter_shrink_tco = spawn (fn() => init_tc authority ())
                    val pre = ()
                    val ext_val = (external_shrinker ext_shrink_val record_shrink_test pre).1
                    val int_val = (internal_shrinker ctx_seq [(record (["theInteger", "theString"], [integer(), string()]))] record_shrink_test pre size 0 inter_shrink_tco).1

                    val ext = append acc.ext [ext_val]
                    val inter = append acc.inter [int_val]
                    in aux {ext, inter} (i-1)
                    end
        in 
            aux {ext = [], inter = []} n
        end
    val test = test_shrinking 100
    val ext_sum = foldl (fn (x,y) => x+y) 0 test.ext
    val inter_sum = foldl (fn (x,y) => x+y) 0 test.inter
    val ext_mean = ext_sum/100
    val inter_mean = inter_sum/100
in
    print ("external timings: " ^ (toString test.ext));
    print ("mean: " ^ (toString ext_mean));
    print ("internal timings: " ^ (toString test.inter));
    print ("mean: " ^ (toString inter_mean))
end