import lists  
(* 
--------------------------------
PRINTING TO CONSOLE

Simple functions for more convenient printing to console.

-------------------------------- 
*)
let val out = getStdout authority
    fun write x = fwrite (out, x)

    fun args_toString args = 
        let fun aux_toString acc (x0::x1::xs) = aux_toString (acc ^ (toString x0) ^ ", ") (x1::xs)
            | aux_toString acc (x::xs) = acc ^ (toString x) in 
        aux_toString "" args end
(* 
--------------------------------
ERROR HANDLING

Handles the printing of appropriate error messages for errors that may occur in the use of TroupeCheck.

-------------------------------- 
*)
    fun report_error error_reason = 
        write "\u001B[31m \nError: "; (* Changing the print color to red *)
        let val err_string = case error_reason of 
            ("cant_generate", tries) => "Couldn't produce an instance that satisfies all strict constraints after "
                                            ^ (toString tries) ^ " tries.\n"
            | ("cant_satisfy", tries) => "No valid test could be generated after " ^ (toString tries) ^ " tries.\n"
            | ("non_boolean_result", _) => "The property or precondition code returned a non-boolean result.\n"
            | ("type_mismatch", _) => "The types' structure doesn't match the property.\n"
            | ("illegal_gen_def", _ ) => "Generator is defined wrong - use tuple() or record() to combine generators.\n"
            | ("record_mismatch", _) => "the number of names provided for record generation, does not match the number of types provided.\n"
            | ("shrinking_looped", _) => "Shrinking looped.\n"
            | ("non_string_type", _) => "An element of non-string type found when trying to convert list to string.\n"
        in
        write (err_string ^ "\u001B[0m"); (* Changing the color back *)
        exit (authority, 0) end
    
    fun boolean_check x = 
        if (getType x)<>"boolean" then report_error ("non_boolean_result", 0) else ()

    fun function_not_done_check p = 
        if (getType p)<>"function" then report_error ("type_mismatch", 0) else ()
(*
--------------------------------
UTILS

Different utility functions that are used across the library.

-------------------------------- 
*)  
    fun remove_nth n [] i = []
    | remove_nth n (x::xs) i = 
        if n = i then xs
        else x :: (remove_nth n xs (i + 1))
    
    fun make_list (f, i) = 
        case i of 
        0 => []
        | _ => append [f()] (make_list (f, i-1))
    
    fun abs_value x = 
    if x < 0 then -x else x 

(* TODO: handle when arguments are passed to a property that does not take arguments *)
    fun apply_args p l =
        case l of 
            [] => boolean_check (p()); p() (* this case is only reached if there are no generators to begin with *)
            | (x::xs) => 
                let val res = foldl (fn (x,y) => function_not_done_check y; y x) p l in
                boolean_check res;
                res 
                end
    
    fun string_to_list s = 
        let fun aux "" acc = acc 
            | aux s acc = 
                let val x = substring (s, 0, 1)
                    val xs = substring (s, 1, 1/0) in 
                aux xs (append acc [x]) end in 
        aux s [] end
    
    (* Combines a list of individual strings to a single string *)
    fun list_to_string ls = 
        foldl (fn (x,y) => if getType x <> "string" then report_error ("non_string_type", 0) else y ^ x) "" ls
    
    fun string_length s = 
        length (string_to_list s)

    fun report_fail_reason rec noOfTests= 
        case rec.failReason of
            "false_prop" => 
                write "\nFailure at input: ";
                write (args_toString rec.ctx);
                write ("\nAfter running: " ^ (toString (noOfTests - rec.remTests + 1)) ^ " test(s)\n")
    
    fun build_record names vals = 
        let fun aux r [] [] = r 
            | aux r (n::ns) (v::vs) = 
                aux (recordExtend(r, n, v)) ns vs in
        aux {} names vals 
        end
    
    (* Hardcoded until a tuple from list function is implemented in Troupe - an issue has been raised on GH.*)
    fun build_tuple ls = 
                case ls of 
                [] => (0)
                |[x] => (x) 
                |[x1,x2] => (x1,x2)
                |[x1,x2,x3] => (x1,x2,x3)
                |[x1,x2,x3,x4] => (x1,x2,x3,x4)
                |[x1,x2,x3,x4,x5] => (x1,x2,x3,x4,x5)
                |[x1,x2,x3,x4,x5,x6] => (x1,x2,x3,x4,x5,x6)
                |[x1,x2,x3,x4,x5,x6,x7] => (x1,x2,x3,x4,x5,x6,x7)
                |[x1,x2,x3,x4,x5,x6,x7,x8] => (x1,x2,x3,x4,x5,x6,x7,x8)
                |[x1,x2,x3,x4,x5,x6,x7,x8,x9] => (x1,x2,x3,x4,x5,x6,x7,x8,x9)
                |[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10] => (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)
                |_ => (2, 3, 4, 5) 
    
        fun dec_nth list idx = 
        let fun dec_nth_aux [] acc i = acc 
            | dec_nth_aux (x::xs) acc i =
                case i = idx of 
                true =>
                    let val dec_val = if x-1 <= 0 then 0 else floor (x/2) in
                    dec_nth_aux xs (append acc [dec_val]) (i+1) end
                | false => dec_nth_aux xs (append acc [x]) (i+1)
        in  
            dec_nth_aux list [] 0 end
    
    fun dec_all seq = 
        let fun dec_all_aux [] i = [] 
            | dec_all_aux (x::xs) i = 
                if x = 0 then
                    dec_all_aux xs (i+1)
                else 
                    append  [(fn () => (dec_nth seq i))] [fn () => dec_all_aux xs (i+1)] in 
        dec_all_aux seq 0 end
    
    fun seqs_of_seq sequence lengths = 
        let fun aux seq acc 0 = (acc, seq) 
            | aux (x::xs) acc n = 
                aux xs (append acc [x]) (n-1) in 
        (foldl (fn (x,(acc, s)) => 
                                let val (curr_acc, curr_seq) = aux s [] x in 
                                (append acc [curr_acc], curr_seq) end)([], sequence) lengths).0 end

    fun cutoff_at list idx = 
        let fun aux ls acc 0 = acc
            | aux (x::xs) acc i = 
                aux xs (append acc [x]) (i-1) in 
        aux list [] idx end 
    
    fun for_i body 0 = body() 
    | for_i body to = body(); for_i body (to-1)
(* 
--------------------------------
SHRINKING

Works by first using random shrinking when a failing example has been found (shrink & random_shrink_aux). 
Random shrinking means simply generating new test cases with gradually smaller size, to find a case smaller than the original one. This rarely produces a minmal result.
The smallest randomly shrunk instance is then further shrunk using integrated shrinking. (integrated_shrink & shrink_aux)
Integrated shrinking means keeping track of all random decision made during generation, and then re-generating with smaller "random" decisions.

This part of the code also contains the functionality for recording all random decisions, and replaying these random decisions (produce_rng, rc_rng & rep_rng).
All of these functions are spawned and then requests or updates may be send to them, so that the correct RNG's are used at different points in the code.

-------------------------------- 
*)  
    fun produce_rng rng = 
        receive [hn ("REQUEST_RNG", senderid) => 
                    let val _ = send (senderid, rng) 
                    in produce_rng rng end,
                
                hn ("UPDATE_RNG", senderid, new_rng) => 
                    let val _ = send(senderid, "done") in
                    produce_rng new_rng end]

    val rng_producer = spawn (fn() => produce_rng ())


    fun rec_rng ls =
    receive [hn ("REQUEST_RND", senderid) =>
                let val rnd = floor (random()*1000000) 
                    val _ = send (senderid, rnd) 
                    in rec_rng (append ls [rnd])
                    end, 
            hn ("REQUEST_SEQ", senderid) => 
                let val _ = send (senderid, ls)
                in rec_rng []
                end]
    
    fun rep_rng ls = 
        receive [hn ("REQUEST_RND", senderid) => 
                    case ls of 
                    (x::xs) => 
                        let val _ = send (senderid, x) 
                        in rep_rng xs
                        end 
                    | [] => 
                        let val _ = send (senderid, 0)
                        in rep_rng ls 
                        end, 
                hn ("REQUEST_LEFT", senderid) => 
                    let val _ = send (senderid, ls)
                    in rep_rng [] 
                    end, 
                hn ("UPDATE_LS", new_ls) => 
                    rep_rng new_ls]

    fun shrink_aux seqs gens lengths prop pre size counter = 
        let val _ = send(rng_producer, ("REQUEST_RNG", self())) 
            val pid = receive [hn x => x]
        in case seqs of 
        (x1::x2::x3::xs) => 
            let val seqs_of_curr = seqs_of_seq (x2()) lengths
                val args_and_leftovers = mapi (fn (i, x) =>
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = x size
                                            val _ = send (pid, ("REQUEST_LEFT", self()))
                                            val left_overs = receive [hn x => x] 
                                        in (arg, left_overs)
                                        end) gens

                val (test_args, left_over_seqs) = foldl (fn (x, (raws, left_overs)) => (append raws [x.0], append left_overs [x.1])) ([],[]) args_and_leftovers
                val ret_seqs = mapi (fn (i,x) => 
                                        if (length x) = 0 then (nth seqs_of_curr (i+1)) 
                                        else cutoff_at (nth seqs_of_curr (i+1)) ((nth lengths (i+1))-(length x))) left_over_seqs
                val precond_is_met = if (pre <> ()) then (apply_args pre test_args) else true 
            in
                case (apply_args prop test_args) orelse (precond_is_met = false) of 
                true => shrink_aux (x1::x3()) gens lengths prop pre size counter
                | false => integrated_shrink ret_seqs gens prop pre size (counter+1)
            end  
        | (x::xs) => 
            let val seqs_of_curr = seqs_of_seq (x()) lengths
                val test_args = mapi (fn (i, y) => 
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = y size 
                                            in arg end) gens
                val precond_is_met = if (pre <> ()) then (apply_args pre test_args) else true
            in  
                case (apply_args prop test_args) orelse (precond_is_met = false) orelse (size < 0) of 
                    true => 
                        let val res = mapi (fn (i, y) => 
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = y (size+1) 
                                            in arg end) gens in 
                        {shrunk_ctx = res, count = counter} end
                    | false => shrink_aux [x] gens lengths prop pre (size-1) counter
                
            end 
        end

    and integrated_shrink sequences gens prop pre size counter = 
        let val (seqs_comb, seq_lengths) = foldl (fn (x, (seq, lengths)) => ((append seq x), (append lengths [(length x)]))) ([], []) sequences
        in
            if foldl (fn (x,y) => (x = 0) andalso y) true seqs_comb then 
                shrink_aux [seqs_comb] gens seq_lengths prop pre size counter
            else  
                let val decreased_seqs = dec_all seqs_comb
                    val dec_seqs_w_root = append [fn() => seqs_comb] decreased_seqs
                    val res = shrink_aux dec_seqs_w_root gens seq_lengths prop pre size (counter)
                in 
                res end
        end
    
    fun random_shrink_aux sequences generators prop pre success size counter =
        if (counter = 1000) orelse (size = 0) then {count = success, size = size, sequences = sequences} else
        let val _ = send(rng_producer, ("REQUEST_RNG", self()))
            val pid = receive [hn x => x]
            val new_size = size-1
            val (shrunk_args, shrunk_sequences) = 
                                        foldl (fn (x, (arg_acc, seq_acc)) => 
                                                let val arg = x new_size
                                                    val _ = send (pid, ("REQUEST_SEQ", self()))
                                                    val seq = receive [hn x => x]
                                                in (append arg_acc [arg], append seq_acc [seq]) 
                                                end) ([],[]) generators
            val precond_is_met = if (pre <> ()) then (apply_args pre shrunk_args) else true 
        in
            case (apply_args prop shrunk_args) orelse (precond_is_met = false) of
                true => random_shrink_aux sequences generators prop pre success size (counter+1)
                | false =>
                    random_shrink_aux shrunk_sequences generators prop pre (success+1) new_size (0)
        end

    fun shrink sequence generators prop pre size counter = 
        let val rng_recorder = spawn (fn() => rec_rng [])
            val _ = send (rng_producer, ("UPDATE_RNG", self(), rng_recorder))
            val _ = receive [hn x => ()]
            val res = random_shrink_aux sequence generators prop pre 0 size counter
            val rng_replayer = spawn (fn() => rep_rng [])
            val _ = send (rng_producer, ("UPDATE_RNG", self(), rng_replayer))
            val _ = receive [hn x => ()]
        in 
        integrated_shrink (res.sequences) generators prop pre res.size (res.count) end 
(*
--------------------------------
GENERATORS

Contains generators for Troupe's built-in types. All generators must return a single instance of the type they generate, 
and take a 'size' argument as the very last argument.
This size will be given to all generators in the generation of test cases (and shrinking).
Generators that take more arguments, will need to have these passed along to them before passing the generator to the testing facilities
(convenience functions for this are supplied later). 

It is recommended that all user defined generators only make use of pre-defined generators or their matching convenience functions
for random decisions (i.e. a call to float_gen/float() or int_gen/integer()), instead of having to send and receive the correct messages to the RNG threads.
However, it can be done if the users wishes to and understands what is going on.

-------------------------------- 
*)  
    fun float_gen (low, high) size = 
        let val _ = send (rng_producer, ("REQUEST_RNG", self()))
            val pid = receive [hn x => x]

            val _ = send (pid, ("REQUEST_RND", self()))
            val x = receive [hn x => x]

            val _ = send (pid, ("REQUEST_RND", self()))
            val bool_int = receive [hn x => x]
            
            val bool = bool_int < (1000000/2) 
            val float_of_x = x/1000000

            val lInf = low = 1/0 (* check for inf *)
            val hInf = high = 1/0

            val res = 
                case (lInf, hInf) of 
                    (true, true) => if bool then float_of_x * size else -float_of_x * size
                    | (true, false) => high - (float_of_x * size) 
                    | (false, true) => low + (float_of_x * size)
                    | (false, false) => low + (float_of_x * (high-low)) 
        in res
        end
    
    fun int_gen (low, high) size = 
        let val res = floor (float_gen (low, high+1) size)
        in res
        end

    fun bool_gen size = 
        let val rnd = int_gen (0,1) size
            val res = if rnd = 0 then false
                      else true 
        in res
        end

    fun list_gen (generator) size = 
        let val length = (int_gen (0, size) size)
            val res = make_list ((fn () => generator size), length) 
        in res
        end

    (* NOTE: Generates only letters (upper and lower case) and numbers. *)
    fun char_gen size =
        let val chars = 
            ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
            "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
            val x = (int_gen (1, ((length chars)-1)) size)
        in nth chars x 
        end

    (* NOTE: Generates only strings of letters (upper and lower case) and numbers. *)
    fun string_gen size = 
        let val char_ls = list_gen (char_gen)  size
            val string = list_to_string char_ls
        in string
        end

    (* ts: list of generators - used to generate values for fields *)
    (* NOTE: Hardcoded for tuple of up to 10 elements  - see build_tuple in 'UTILS' *)
    fun tuple_gen ts size = 
        let val ts_vals = map (fn x => x size) ts
        in build_tuple ts_vals
        end

    (* ns: list of strings - will be used as fieldnames *)
    (* ts: list of generators - used to generate values for fields *)    
    fun rec_gen ns ts size = 
        if (length ns) <> (length ts) then 
            report_error ("record_mismatch", 0)
        else 
            let val ts_vals = map (fn x => x size) ts
                val res = build_record ns ts_vals 
            in res
            end 

    (* TODO: needs to be completed... *)
    fun generator_gen size = 
        let val rnd = int_gen (1,7) size
            val inf = 1/0
            val res = if rnd = 1 then ((fn i => int_gen (inf, inf) i)) else 
                      if rnd = 2 then ((fn i => bool_gen i)) else 
                      if rnd = 3 then ((fn i => float_gen (inf, inf) i)) else
                      if rnd = 4 then ((fn i => string_gen i)) else
                      if rnd = 5 then ((fn i => char_gen i)) else
                      if rnd = 6 then ((fn i => tuple_gen (make_list ((fn () => int_gen(inf, inf) i), i)) i)) else
                     ((fn i => list_gen (int_gen(inf, inf)) i)) in
        res end
        
(* 
--------------------------------
CORE FUNCTIONALITY

Handles running the tests (core_forall), shrinking, preparing the recorder RNG and reporting the results to the user (tc).

-------------------------------- 
*)              
    fun core_forall (generators, prop, 0, size, pre, cap) = {failReason = (), ctx = (), ctx_seq = (), remTests = 0, size = size}
        |core_forall (generators, prop, i, size, pre, cap) =  
            let val _ = send(rng_producer, ("REQUEST_RNG", self()))
                val pid = receive [hn x => x]
                val (args, sequences) = foldl (fn (x, (arg_acc, seq_acc)) => 
                                                let val arg = x size
                                                    val _ = send (pid, ("REQUEST_SEQ", self()))
                                                    val seq = receive [hn x => x]
                                                in (append arg_acc [arg], append seq_acc [seq]) 
                                                end) ([],[])generators
            in
                case pre of 
                    () => 
                        if (apply_args prop args) then (write "."; core_forall (generators, prop, i-1, size+1, pre, cap))
                        else 
                            let val _ = write "!" 
                            in {failReason = "false_prop", ctx = args, ctx_seq = sequences, remTests = i, size = size} 
                            end
                    | _ => 
                        if (apply_args pre args) then 
                            if (apply_args prop args) then (write "."; core_forall (generators, prop, i-1, size+1, pre, cap))
                            else 
                                let val _ = write "!" 
                                in {failReason = "false_prop", ctx = args, ctx_seq = sequences, remTests = i, size = size} 
                                end
                        else 
                        let val _ = write "x"
                        in if (size = cap) andalso (i*5 = cap) then report_error ("cant_satisfy", size)
                            else if size = cap then {failReason = (), ctx = (), ctx_seq = (), remTests = i, size = size}
                            else core_forall (generators, prop, i, size+1, pre, cap) 
                        end
            end

    fun for_all (generators, p) = for_all (generators, p, 100)
    | for_all (generators, p, noOfTests) = 
        let val (prop, pre) = 
                case p of    
                    (x,y) => (x,y)
                    | x => (x, ())
            val rng_recorder = spawn (fn() => rec_rng [])
            val _ = send (rng_producer, ("UPDATE_RNG", self(), rng_recorder))
            val _ = receive [hn x => ()]
            val res = core_forall (generators, prop, noOfTests, 0, pre, (noOfTests*5)) in 
            case res.failReason of
                () => write ("\u001B[1m \u001B[32m \nSuccess: \u001B[0mPassed all " ^ (toString noOfTests) ^ " test(s).\n"); true
                |_ => 
                    report_fail_reason res noOfTests; 
                    write ("\u001B[1m\u001B[34mShrinking\u001B[0m:");
                    let val shrink_res = shrink res.ctx_seq generators prop pre res.size 0 in
                    write "\nFailing test case was shrunk to:\n";
                    write (args_toString shrink_res.shrunk_ctx);
                    write ("\nAfter " ^ (toString shrink_res.count) ^ " iterations.\n");
                    false
                    end
        end

    fun troupecheck props = 
        let val n = toString (length props)
            fun troupecheck_aux [] i = exit (authority, 0)
            | troupecheck_aux (x::xs) i =
                let val _ = write ("\nRunning test " ^ (toString i) ^ " of " ^ n ^ ":\n")
                    val self_id = self()
                    val _ = spawn (fn () => let val res = x() in send(self_id, "done") end )
                    val _ = receive [hn x => ()] 
                in troupecheck_aux xs (i+1) end
        in troupecheck_aux props 1 
        end

(* 
--------------------------------
CONVENIENCE FUNCTIONS 

These are functions that make it easier for the user to make use of the different generators, and define their own generators.

-------------------------------- 
*)
    val inf = 1 / 0
    fun integer() = int_gen(inf, inf)
        | integer (h, l) = int_gen(h, l)
    
    fun pos_integer() = integer(0, inf)

    fun neg_integer() = integer(inf, -1)

    fun float() = float_gen(inf, inf)
        | float(h, l) = float_gen(h, l)

    fun pos_float() = float(0, inf)

    fun neg_float() = float(inf, 0)

    fun boolean() = bool_gen

    fun list() = list_gen(generator_gen()) 
        |list(type) = list_gen(type)

    fun string() = string_gen

    fun char() = char_gen

    fun tuple ts = tuple_gen ts
    
    fun record ns ts = rec_gen ns ts

    fun one_of ls = 
        let val idx = (int_gen (1, (length ls)) ((length ls)))
        in 
            (nth ls idx)
        end   
(* 
--------------------------------
FUNCTIONS FOR TESTING

These functions exist only to define some test properties later, which are used in the development of TroupeCheck, to make sure it works as expected.

-------------------------------- 
*) 
    fun my_reverse xs = 
        xs
    
    fun my_floor i =
        if i >=0 then i - (i mod 1)
        else i - (i mod 1) - 1

    fun my_length [] = 0
        | my_length (x::xs) = 1 + (my_length xs)

    fun my_count y [] = 0
        | my_count y (x::xs) = 
            let val z = 
                if y = x then 1 else 0 
            in 
            z + my_count y xs end 
    
    fun my_floor i =
        if i >=0 then i - (i mod 1)
        else i - (i mod 1) - 1
    
    fun my_ceil_1 i =
        if i > 0 then i + (1 - (i mod 1))
        else i + (1 - (i mod 1)) - 1
    
    fun my_ceil_2 i =
        if i > 0 then (my_floor i) + 1
        else if i = 0 then 0
        else (my_floor i) + 1
    
    fun bad_insert xs x = 
        if length xs < 10 then append [x] xs else
        xs

    fun one_of_two (x, y) size =
        let val bool = (bool_gen size) in
        if bool then x size
        else y size end    
    
    fun bad_half n = 
        if n > 10 then n else n/2

    fun lengths_not_same s1 s2 = 
        (string_length s1) <> (string_length s2)    
    
(*
--------------------------------
PROPERTY FUNCTIONS FOR TESTING

See 'FUNCTIONS FOR TESTING'.

-------------------------------- 
*)
    fun bool_commutative x y = 
        (x andalso y) = (y andalso x)
    
    fun number_commutative x y = 
        x * y <= 50

    fun list_reverse xs = 
        reverse(reverse xs) = xs
    
    fun int_gen_stays_in_interval i = 
        (integer(0, i) i) <= i 
    
    fun abs_value_is_always_pos i =
        abs_value i >= 0
    
    fun my_floor_test i =
        my_floor i = floor i

    fun my_length_test xs = 
        my_length xs = length xs
    
    fun make_list_test i = 
        let val generator = generator_gen i
            fun f() = generator (int_gen(0, inf) i) 
            val ls = (make_list (f, i)) in
        (length ls) = i end
    
    fun my_count_returns_non_negative_int x xs = 
        (my_count x xs) >= 0
    
    fun rec_test rec i = 
        {theInteger = rec.theInteger, theString = rec.theString, z = i} = {rec with z = i}

    fun pre_pos x = 
        x >= 0

    fun my_floor_test i =
        my_floor i = floor i

    fun my_ceil_1_test i =
        my_ceil_1 i = ceil i
    
    fun my_ceil_2_test i =
        my_ceil_2 i = ceil i
    
    fun both_ceil_test i =
        my_ceil_1 i = my_ceil_2 i
    
    fun tup_test x y z w = x+y+z+w < 100 (* = w+z+y+x *)

    fun no_args() = true

    fun test_bad_insert xs x =
        length (bad_insert xs x) = (length xs) + 1 
    
    fun test_bad_half n = 
        n > (bad_half n)
    
    fun append_always_longer s1 s2 = 
        string_length s1 < string_length (s1 ^ s2)
    
    fun record_shrink_test r = 
        r.theInteger < 50

(* 
--------------------------------
PROPERTIES FOR TESTING

see 'FUNCTIONS FOR TESTING'.

-------------------------------- 
 *)
    fun prop_bad_insert() = for_all ([list(integer()), integer()], test_bad_insert)
    fun prop_bad_half() = for_all ([integer()], (test_bad_half, (fn x => x >= 15)))
    fun prop_record_shrink() = for_all ([record ["theInteger", "theString"] [integer(), string()]], record_shrink_test)
    fun prop_not_satisfied() = for_all ([boolean(), boolean()], bool_commutative)
    fun prop_count_non_negative() = for_all ([integer(), list(integer())], my_count_returns_non_negative_int, 1000)
(* 
--------------------------------
USED FOR USERGUIDE

Functions used for demonstrating how to use TroupeCheck in the userguide.

-------------------------------- 
*)
    fun filter_less ([], _) = []
    | filter_less ((x::xs), p) = 
        if x < p then append [x] (filter_less (xs, p)) else (filter_less (xs, p))

    fun filter_greater ([], _) = []
    | filter_greater ((x::xs), p) = 
        if x > p then append [x] (filter_greater (xs, p)) else (filter_greater (xs, p))


    fun my_quicksort [] = []
    | my_quicksort (x::xs) =
        let val smaller = my_quicksort(filter_less(xs, x))
            val greater = my_quicksort(filter_greater(xs, x)) in 
        append (append smaller [x]) (greater) end
    
    fun ordered [] = true
    | ordered (x::[]) = true 
    | ordered (x::y::ys) = 
        if x <= y then ordered (y::ys) else false

    fun my_sort_is_ordered xs = 
        ordered (my_quicksort xs) 
    
    fun my_sort_keep_length xs = 
        length xs = length (my_quicksort(xs))
    
    fun pre_list_size_greater_than_one xs = 
        if (length xs) <= 1 then false else true
    
    fun no_duplicates[] = true 
    | no_duplicates (x::xs) = if (elem x xs) then false else no_duplicates xs

    fun cons_length_increase xs x = 
        (length (x::xs)) = ((length xs) + 1)

    fun list_no_duplicates (generator) size = 
        let val length = (integer(0, size) size)
            fun no_dups_aux acc 0 = acc
            | no_dups_aux acc i = 
                let val value = generator size
                in if elem value acc 
                    then no_dups_aux acc i
                    else no_dups_aux (value::acc) (i-1) 
                end
        in no_dups_aux [] length
        end
    
    fun is_ordered_prop() = for_all ([list(integer())], my_sort_is_ordered)

    fun keep_length_prop() = for_all ([list_no_duplicates(integer())], my_sort_keep_length)

    fun keep_length_fixed_prop() = for_all ([list(integer())], (my_sort_keep_length, no_duplicates))

    fun length_increase_prop() = for_all ([list(integer()), integer()], cons_length_increase)

(*
--------------------------------
TC^2

Functions for testing TroupeCheck using TroupeCheck.

-------------------------------- 
*)
    fun tc_sort_length_always_fails () =    
        for_all ([list(integer())], my_sort_keep_length) = false
    
    fun tc_sort_ordered_always_true () =    
        for_all ([list(integer())], my_sort_is_ordered) = true

(*
--------------------------------
CUSTOM TYPE PROGRAM

Used for testing the creation of complex custom generators.
Here we defined an interpreter and generator for simple programs consisting of: 
expr := ("num", number) |("var", string) |("add", expr, expr) |("sub", expr, expr) |("mul", expr, expr) |("div", expr, expr) 
stmt := ("assign", string, expr) |("print", expr)
prog := [[stmt], expr]

-------------------------------- 
*)
    fun eval exp env =
    case exp of
      ("num", n) => n
    | ("var", n) => lookup env n ("unknown variable " ^ n)
    | ("add", e1, e2) => (eval e1 env) + (eval e2 env)
    | ("sub", e1, e2) => (eval e1 env) - (eval e2 env)
    | ("mul", e1, e2) => (eval e1 env) * (eval e2 env)
    | ("div", e1, e2) => (eval e1 env) / (eval e2 env)
    | _ => print ("Error: ill defined expression"); exit (authority, 1)

    fun execute stmt env =
        case stmt of
        ("assign", var, exp) =>
            let val value = eval exp env
            in
                append [(var, value)] env
            end
        | ("print", exp) => (()(* print ("from prog: " ^ (toString (eval exp env)) *); env)

    fun interpret prog =
        let fun interpretHelper [] env = env
            | interpretHelper (stmt :: rest) env =
                let val newEnv = execute stmt env
                in
                    interpretHelper rest newEnv
                end
            val stmts = remove_nth ((length prog)-1) prog 0
            val exp = nth prog (length prog)
            val last_env = (interpretHelper stmts [])
        in
            eval exp last_env
        end
    
    fun optimize_prog prog =
        let val stmts = remove_nth ((length prog)-1) prog 0
            val exp = nth prog (length prog)
            fun optimize_exp exp =
                case exp of
                ("num", n) => ("num", n)
                | ("var", x) => ("var", x)
                | ("add", e1, e2) => 
                    (case e1 of 
                    ("num", n1) => (case e2 of 
                                    ("num", n2) => ("num", (n1+n2))
                                    |_ => ("add", (optimize_exp e1), (optimize_exp e2)))
                    | _ => ("add", (optimize_exp e1), (optimize_exp e2)))
                | ("sub", e1, e2) => 
                    (case e1 of 
                    ("num", n1) => (case e2 of 
                                    ("num", n2) => ("num", (n1-n2))
                                    |_ => ("sub", (optimize_exp e1), (optimize_exp e2)) )
                    |_ => ("sub", (optimize_exp e1), (optimize_exp e2)))
                | ("mul", e1, e2) => 
                    (case e1 of 
                    ("num", n1) => (case e2 of 
                                    ("num", n2) => ("num", (n1*n2))
                                    |_ => ("mul", (optimize_exp e1), (optimize_exp e2)) )
                    |_ => ("mul", (optimize_exp e1), (optimize_exp e2)))
                | ("div", e1, e2) => 
                    (case e1 of 
                    ("num", n1) => (case e2 of 
                                    ("num", n2) => if ((n1 = 0) andalso (n2 = 0)) then ("div", e1, e2) else ("num", (n1/n2))
                                    |_ => ("div", (optimize_exp e1), (optimize_exp e2)) )
                    |_ => ("div", (optimize_exp e1), (optimize_exp e2)))

            fun optimize_stmt stmt =
                case stmt of
                ("assign", var, exp) => ("assign", var, (optimize_exp exp))
                | ("print", exp) => ("print", (optimize_exp exp))
        in
            append (map optimize_stmt stmts) [optimize_exp exp]
        end 

    fun exp_gen ls nesting_level size = 
        let val exp_ts = 
            if nesting_level = 2 then ["num"] 
            else (if length ls = 0 then ["num", "add", "sub", "mul", "div"] 
            else ["var", "num", "add", "sub", "mul", "div"])
            val exp_type = one_of exp_ts
        in 
            case exp_type of 
            "num" => 
                let val value = int_gen(1, inf) size in
                ("num", value) end
            | "var" => 
                let val value = one_of ls in
                ("var", value) end 
            |"add" => 
                let val e1 = exp_gen ls (nesting_level+1) size 
                    val e2 = exp_gen ls (nesting_level+1) size
                in
                    ("add", e1, e2)
                end
            |"sub" => 
                let val e1 = exp_gen ls (nesting_level+1) size 
                    val e2 = exp_gen ls (nesting_level+1) size
                in
                    ("sub", e1, e2)
                end
            |"mul" => 
                let val e1 = exp_gen ls (nesting_level+1) size 
                    val e2 = exp_gen ls (nesting_level+1) size
                in
                    ("mul", e1, e2)
                end
            |"div" => 
                let val e1 = exp_gen ls (nesting_level+1) size 
                    val e2 = exp_gen ls (nesting_level+1) size
                in
                    ("div", e1, e2)
                end  
        end
    
    fun assign_stmt_gen ls size = 
        let val n = string_gen size 
            val exp = exp_gen ls 0 size 
        in
            ("assign", n, exp)
        end 
    
    fun print_stmt_gen ls size = 
        let val exp = exp_gen ls 0 size 
        in 
            ("print", exp)
        end 

    fun stmt_gen ls size = 
        let val stmt = one_of ["print", "assign"]
        in 
            case stmt of
            "assign" => 
                let val res = assign_stmt_gen ls size in 
                res end
            |"print" => 
                let val res = print_stmt_gen ls size in 
                res end
        end 
    
    fun program_gen size = 
        let val num_of_insts = (int_gen(0, size) size)
            fun prog_gen_aux env p 0 = (p, env) 
            | prog_gen_aux env p i = 
                let val stmt = stmt_gen env size 
                    val newEnv = if stmt.0 = "assign" then (append [stmt.1] env) else env
                in 
                    prog_gen_aux newEnv (append p [stmt]) (i-1)
                end 
            val (prog_stmts, last_env) = prog_gen_aux [] [] num_of_insts
            val last_exp = exp_gen last_env 0 size
            val prog = append prog_stmts [last_exp]                  
        in 
            prog
        end
    
    fun test_prog_opt prog = 
        (interpret prog) = (interpret (optimize_prog prog))
    fun test_prog_shrink prog = 
        (interpret prog) < 100
    fun prop_program_shrink() = for_all ([program_gen], test_prog_shrink)

    
in

troupecheck [keep_length_prop]

(* for_all [list(integer()), integer()] test_bad_insert;
for_all [integer()] (test_bad_half, (fn x => x >= 15));
for_all [string(), string()] (append_always_longer, lengths_not_same);
for_all [record ["theInteger", "theString"] [integer(), string()]] record_shrink_test;
for_all [program_gen] test_prog_opt; *)

(* for_i (fn() => for_all [program_gen] test_prog_shrink) 50 *)
(* for_all [program_gen] test_prog_shrink *)

(*
--------------------------------
ALL TESTS - x
-------------------------------- 
*)
(* for_all [integer(), integer()] number_commutative *)
(* shrinking tests - x *)
(* for_all [list(integer()), integer()] test_bad_insert;
for_all [integer()] (test_bad_half, (fn x => x >= 15));
for_all [string(), string()] (append_always_longer, lengths_not_same);
for_all [record ["theInteger", "theString"] [integer(), string()]] record_shrink_test; *)

(* tc^2 tests *)
(* for_all [] tc_sort_ordered_always_true; *)

(* User guide tests *)
(* for_all [list(integer()), integer()] cons_length_increase;
for_all [list(integer())] my_sort_is_ordered;
for_all [list(integer())] my_sort_keep_length;
for_all [list(integer())] (my_sort_keep_length, no_duplicates) *)

(* General functionality tests *)
(* for_all [(record ["theInteger", "theString"][integer(), string()]), integer()] rec_test;
for_all [] no_args;
for_all [integer(), integer(), integer(), integer()] tup_test;
write "\nTesting on bools commutative:";
for_all [boolean(), boolean()] bool_commutative;
write "\nTesting on numbers commutative:";
for_all [integer(), integer()] number_commutative;
write "\nTesting on list reverse:";
for_all [list(integer())] list_reverse; 
write "\nTesting on int_gen interval:";
for_all [integer()] (int_gen_stays_in_interval, pre_pos);
write "\nTesting on abs_value:";
for_all  [one_of_two (integer(), float())] abs_value_is_always_pos;
write "\nTesting on my_floor:";
for_all  [float()] my_floor_test; 
write "\nTesting that my_count always return non-negative result:";
tc_n [integer(), list(integer())] my_count_returns_non_negative_int 1000;
write "\nTesting my_length:";
for_all [list(integer())] my_length_test;
write "\nTesting make_list:";
for_all [pos_integer()] make_list_test;
write "Testing on my_ceil_1:";
for_all  [float()] my_ceil_1_test;
write "Testing on my_ceil_2:";
for_all  [float()] my_ceil_2_test;
write "Testing on both ceil functions:";
for_all  [float()] both_ceil_test *)
end